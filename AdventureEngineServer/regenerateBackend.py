import os
import re
import pprint


baseTypeDir = './generatedTypes'

goToSqlTypeConversions = {
    'string': 'TEXT',
    '*string': 'TEXT',
    'bool': 'NUMBER',
    '*bool': 'NUMBER',
    '*float64': 'REAL',
    'float64' : 'REAL'
}

autogeneratedWarningMessage = [
    '//*** CAUTION ***',
    '//This is an autogenerated file produced by regenerateBackend.py.',
    '//Edits made here will not persist after backend regeneration.',
]

def indentLineBlock(lines: list):
        return ['   ' + line for line in lines]


def main():
    directory = os.fsencode(baseTypeDir)

    createStatements = []
    insertStatements = []
    tableNames = []

    for file in os.listdir(directory):
        fileName = os.fsdecode(file)

        if fileName.endswith('.go'): 
            tableName = fileName.replace('.go', '').replace('Flattened', '')
            tableNames.append(tableName)
            typeMeta = {}

            try:
                typeMeta = produceParsedType(baseTypeDir + '/' + fileName)

            except Exception as e:
                raise e
            
            createStatements.append(produceCreateTableStatement(tableName, typeMeta))
            insertStatements += produceTestInsertStatements(tableName, typeMeta)

            serviceLines = produceServiceFileForType(tableName, typeMeta)
            serviceFilePath = 'generatedServices/' + tableName + 'Service.go'

            directory = os.path.dirname(serviceFilePath)
            if not os.path.exists(directory):
                os.makedirs(directory)

            f = open(serviceFilePath, 'w')
            f.writelines([i + '\n' for i in serviceLines])

            controllerLines = produceControllerFileForType(tableName)
            controllerFilePath = 'generatedControllers/' + tableName + 'Controller.go'
            directory = os.path.dirname(controllerFilePath)
            if not os.path.exists(directory):
                os.makedirs(directory)

            f = open(controllerFilePath, 'w')
            f.writelines([i + '\n' for i in controllerLines])
    
    
    f = open('endpointManagers/generatedEndpointManager.go', 'w')
    f.writelines([i + '\n' for i in generateEndpointManager(tableNames)])
    f.close()

    f = open('testCreates.sql', 'w')
    f.writelines([i + '\n' for i in createStatements])
    f.close()

    f = open('testInserts.sql', 'w')
    f.writelines([i + '\n' for i in insertStatements])
    f.close()


def produceParsedType(fileName: str):
    fileContent = ''

    try:
        with open(fileName, 'r', encoding='utf-8') as file:
            fileContent = file.read()

    except FileNotFoundError:
        raise FileNotFoundError('Error: The file ' + fileName + ' was not found.')
    
    except Exception as e:
        raise e

    if (fileContent == ''):
        raise Exception('Unexpected: could not recieve file content from ' + fileName)

    #Isolating the main key/value content
    fileContent = fileContent.split('{', 1)[1].split('}', 1)[0]

    #Removing comment lines
    fileContent = re.sub('//(.+)\n', '', fileContent)

    #Removing any additional JSON annotation wrapped like `some annotation`
    #fileContent = re.sub('`[^`]+`', '', fileContent)

    #Trimming newlines and tabs, and isolating field names and types to their own cleaned dictionary
    fileContent = re.sub('\n\n', '\n', fileContent)
    fileContent = re.sub('\t', '', fileContent)

    fileContent = fileContent.split('\n')
    fileContent = [i.strip() for i in fileContent if i != '']
    fileContent = [i.split(' ', 1) for i in fileContent]

    fieldTypes = {
        'attributes': {}, 
        'relationships': {}
    }

    #Checking for relationship-specific delimiters to know which fields are foreign keys
    #and removing the `json annotation` containing said delimiter afterwards
    for field in fileContent:
        if ( '__' not in field[1]):
            fieldTypes['attributes'][field[0]] = re.sub('`[^`]+`', '', field[1]).strip()
        else:
            fieldTypes['relationships'][field[0]] = {
                field[0]: re.sub('`[^`]+`', '', field[1]).strip(),
                'correspondingTable': re.findall(r'(\w*%s\w*)' % '__', field[1])[0].split('__')[1].capitalize()
            }

    #resulting dict structure for a type/table:
    #{
    #   'attributes': {
    #       'field': 'type'
    #   }
    #
    #   'relationships': {
    #       'field': {
    #           'field': 'type'
    #           'correspondingTable': 'tableName'
    #       }
    #   }
    #}

    return fieldTypes


#The following expect a dictionary in the return shape specified for produceParsedTypes

def produceCreateTableStatement(tableName: str, typeMeta: dict):

    def generateForeignKeyConstraintSnippet(columnName: str, targetTable: str):
        #The id name is currently locked as 'Id' from generation further up

        return 'CONSTRAINT fk_' + targetTable + ' FOREIGN KEY (' + columnName + ') REFERENCES ' + targetTable + '(Id)'
    
    def generateColumnSnippet(columnName: str, goType: str):
        return columnName + ' ' + goToSqlTypeConversions[goType]

    createTableStatement = 'CREATE TABLE IF NOT EXISTS ' + tableName + '(Id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT'
    
    columnSnippets = []
    constraintSnippets = []

    for attribute in list(typeMeta['attributes'].keys()):
        if (attribute != 'Id'):
            #Id is already added at the front as a special case
            columnSnippets.append(generateColumnSnippet(attribute, typeMeta['attributes'][attribute]))

    for relationship in list(typeMeta['relationships'].keys()):
        columnSnippets.append(generateColumnSnippet(relationship, typeMeta['relationships'][relationship][relationship]))
        constraintSnippets.append(generateForeignKeyConstraintSnippet(relationship, typeMeta['relationships'][relationship]['correspondingTable']))

    for snippet in columnSnippets:
        createTableStatement = createTableStatement + ', ' + snippet

    for snippet in constraintSnippets:
        createTableStatement = createTableStatement + ', ' + snippet

    return createTableStatement + ');'


def produceTestInsertStatements(tableName: str, typeMeta: dict):
    
    def getTestTypeDefault(columnName: str, goType: str, numberSeed: int):
        testTypeDefaults = {
            'TEXT': ''' + columnName + ' ' + str(numberSeed) + ''',
            'NUMBER': numberSeed,
            'REAL': float(numberSeed),
        }

        return str(testTypeDefaults[goToSqlTypeConversions[goType]])


    def generateInsertStatement(insertSeed: int):
        baseInsertStatement = 'INSERT INTO  ' + tableName + '(' 

        columnOrder = list(typeMeta['attributes'].keys())

        for column in columnOrder:
            if (column != 'Id'):
                baseInsertStatement = baseInsertStatement + column + (', ' if column != columnOrder[-1] else '')
        
        baseInsertStatement += ') VALUES('

        for column in columnOrder:
            if (column != 'Id'):
                baseInsertStatement += getTestTypeDefault(column, typeMeta['attributes'][column], insertSeed) + (', ' if column != columnOrder[-1] else '')
                insertSeed += 1

        baseInsertStatement += ');'

        return baseInsertStatement
    

    return [generateInsertStatement(i) for i in range(3)]


def produceServiceFileForType(tableName: str, typeMeta: dict):

    dbArgName = 'db'
    objectArgName = tableName[0].lower() + tableName[1:]

    def produceServiceSaveMethod(tableName: str):
    
        lines = [
            'func Save' + tableName + '(' + dbArgName + ' *gorm.DB, ' + objectArgName + ' *types.' + tableName + 'Json) error {',
            *indentLineBlock([
                'tx := ' + dbArgName + '.Begin()',
                '',
                'if tx.Error != nil {',
                    'return errors.New("Could not initialize transaction to save " + reflect.TypeOf(' + objectArgName + ').Name() + " entity")',
                '}',
                '',
                'defer func() {',
                *indentLineBlock([
                    'if r := recover(); r != nil {',
                    '   tx.Rollback()',    
                    '}'
                ]),
                '}()',
                '',
                'if err := tx.Error; err != nil {',
                '   return err',
                '}',
                '',
                'if err := tx.Save(' + objectArgName + ').Error; err != nil {',
                '   tx.Rollback()',
                '   return err',
                '}',
                '',
                'return tx.Commit().Error',
            ]),
            '}'
        ]

        return lines
    

    def produceServiceGetAllMethod(tableName: str):
    
        lines = [
            'func Get' + tableName + 's(' + dbArgName + ' *gorm.DB, ' + objectArgName  + 's *[]types.' + tableName + 'Json) error {',
            *indentLineBlock([
	            'result := db.Find(' + objectArgName + 's)',
                'return result.Error',  
            ]),
            '}'
        ]

        return lines


    def produceServiceGetByIdMethod(tableName: str):
    
        lines = [
            'func Get' + tableName + 'ById(' + dbArgName + ' *gorm.DB, id int, ' + objectArgName  + ' *types.' + tableName + 'Json) error {',
            *indentLineBlock([
	            'result := db.First(' + objectArgName + ', id)',
                'return result.Error',  
            ]),
            '}'
        ]

        return lines
    

    lines = [
        *autogeneratedWarningMessage,
        '',
        'package generatedservices',
        'import (',
        *indentLineBlock([
            '"errors"',
            '"reflect"',
            'types "AdventureEngineServer/generatedTypes"',
  	        '"gorm.io/gorm"'
        ]),
        ')',
        '',
        *produceServiceGetAllMethod(tableName),
        '',
        *produceServiceGetByIdMethod(tableName),
        '',
        *produceServiceSaveMethod(tableName),
    ]

    return lines


def produceControllerFileForType(tableName: str):

    dbArgName = 'db'
    objectArgName = tableName[0].lower() + tableName[1:]

    def produceControllerGetMethod(tableName: str):
        
        contextArgName = 'ctx'
        objectArgName = tableName[0].lower() + tableName[1:]

        lines = [
            'func Get' + tableName + 's(' + contextArgName + ' *gin.Context, ' + dbArgName + ' *gorm.DB) {',
            *indentLineBlock([
                'var returnBuffer []types.' + tableName + "Json",
                'err := services.Get' + tableName + 's(' + dbArgName + ', &returnBuffer)',
                'if err != nil {',
                *indentLineBlock([
                    'ctx.IndentedJSON(http.StatusInternalServerError, err.Error())',
                    'return'
                ]),
                '}',
                'ctx.IndentedJSON(http.StatusOK, returnBuffer)'
	        ]),
            '}'
        ]

        return lines
    
    def produceControllerGetByIdMethod(tableName: str):
        contextArgName = 'ctx'
        objectArgName = tableName[0].lower() + tableName[1:]

        lines = [
            'func Get' + tableName + 'ById(' + contextArgName + ' *gin.Context, ' + dbArgName + ' *gorm.DB) {',
            *indentLineBlock([
                'id := ctx.Param("id")',
                'idNum, err := strconv.Atoi(id)',
                'if err != nil {',
                *indentLineBlock([
                    contextArgName + '.IndentedJSON(http.StatusInternalServerError, err.Error())',
                    'return'
                ]),
                
                '}',
                'var returnBuffer types.' + tableName + "Json",
                'err = services.Get' + tableName + 'ById(' + dbArgName + ', idNum, &returnBuffer)',
                'if err != nil {',
                *indentLineBlock([
                    contextArgName + '.IndentedJSON(http.StatusInternalServerError, err.Error())',
                    'return'
                ]),
                '}',
                'ctx.IndentedJSON(http.StatusOK, returnBuffer)'
	        ]),
            '}'
        ]

        return lines

    def produceControllerSaveMethod(tableName: str):
        contextArgName = 'ctx'
        objectArgName = tableName[0].lower() + tableName[1:]

        lines = [
            'func Save' + tableName + '(' + contextArgName + ' *gin.Context, ' + dbArgName + ' *gorm.DB) {',
            *indentLineBlock([
                'var returnBuffer types.' + tableName + "Json",
                'err := services.Save' + tableName + '(' + dbArgName + ', &returnBuffer)',
                'if err != nil {',
                *indentLineBlock([
                    'ctx.IndentedJSON(http.StatusInternalServerError, err.Error())',
                    'return'
                ]),
                '}',
                'ctx.IndentedJSON(http.StatusOK, returnBuffer)'
	        ]),
            '}'
        ]

        return lines

    lines = [
        *autogeneratedWarningMessage,
        '',
        'package generatedcontrollers',
        'import (',
        *indentLineBlock([
  	        '"github.com/gin-gonic/gin"',
  	        '"gorm.io/gorm"',
            '"strconv"',
            '"net/http"',
            'services "AdventureEngineServer/generatedServices"',
            'types "AdventureEngineServer/generatedTypes"'
        ]),
        ')',
        '',
        *produceControllerGetMethod(tableName),
        '',
        *produceControllerGetByIdMethod(tableName),
        '',
        *produceControllerSaveMethod(tableName)
    ]

    return lines


#This requires all tablenames instead of being applied 1 by 1 as it is generating the full file managing all generated table endpoints
def generateEndpointManager(tableNames: list[str]):
    ginContextName = 'router'
    dbContextName = 'db'

    def produceEndpointsForTable(tableName: str):
        lines = [
            'router.GET("/get' + tableName + '", produceDBContextInjectedEndpoint(' + ginContextName + ', ' + dbContextName + ', controllers.Get' + tableName + 's))',
            'router.GET("/get' + tableName + ':id", produceDBContextInjectedEndpoint(' + ginContextName + ', ' + dbContextName + ', controllers.Get' + tableName + 'ById))',
            'router.POST("/save' + tableName + '", produceDBContextInjectedEndpoint(' + ginContextName + ', ' + dbContextName + ', controllers.Save' + tableName + '))',
        ]

        return lines

    lines = [
        *autogeneratedWarningMessage,
        '',
        'package endpointManagers',
        'import (',
        *indentLineBlock([
  	        '"github.com/gin-gonic/gin"',
              '"gorm.io/gorm"',
            'controllers "AdventureEngineServer/generatedControllers"'
        ]),
        ')',
        '',
        'func produceDBContextInjectedEndpoint(' + ginContextName + ' *gin.Engine, ' + dbContextName + ' *gorm.DB, endpointHandler func(*gin.Context, *gorm.DB)) gin.HandlerFunc {',
        *indentLineBlock([
            'return func(ctx *gin.Context) {',
		    '   endpointHandler(ctx, ' + dbContextName + ')',
	        '}',
        ]),
        '}',
        '',
        'func ApplyGeneratedEndpoints(' + ginContextName + ' *gin.Engine, ' + dbContextName + ' *gorm.DB) {',
        #A little bit of code golf, as a treat (just unpacking the list of lists of generated lines since Python doesn't like embedding * syntax in here)
        *indentLineBlock([item for sublist in [produceEndpointsForTable(tableName) for tableName in tableNames] for item in sublist]),
        '}'
    ]

    return lines

if __name__ == '__main__': main()