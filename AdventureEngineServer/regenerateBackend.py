import os
import re
import pprint
from utils.utils import produceDatabaseTargetType, produceParsedType, goToSqlTypeConversions

goTypeBaseDir = './goTypeBase'
dbTypeTargetDir = './generatedDatabaseTypes'
DTOTargetDir = './generatedDTOs'

autogeneratedWarningMessage = [
    '//*** CAUTION ***',
    '//This is an autogenerated file produced by regenerateBackend.py.',
    '//Edits made here will not persist after backend regeneration.',
]

#global context used for cross-service type reaching
typeMetas = {}

def indentLineBlock(lines: list):
        return ['   ' + line for line in lines]


def main():
    goTypeBaseDirectory = os.fsencode(goTypeBaseDir)

    dbTargetDir = os.path.dirname(dbTypeTargetDir)
    if not os.path.exists(dbTargetDir):
        os.makedirs(dbTargetDir)

    #Parsing types and adding results to the global context
    for file in os.listdir(goTypeBaseDirectory):
        fileName = os.fsdecode(file)

        if fileName.endswith('.go'): 
            tableName = fileName.replace('.go', '')

            try:
                typeMetas[tableName] = produceParsedType(goTypeBaseDir + '/' + fileName)
            except Exception as e:
                raise e

    print("Go types successfully parsed.")

    #Primary file generation for services, DTOs, SQL, and endpoint setup
    createStatements = []
    insertStatements = []
    tableNames = []

    for file in os.listdir(goTypeBaseDirectory):
        fileName = os.fsdecode(file)

        if fileName.endswith('.go'): 
            tableName = fileName.replace('.go', '')
            tableNames.append(tableName)
            typeMeta = typeMetas[tableName]

            try:
                typeMeta = produceParsedType(goTypeBaseDir + '/' + fileName)
                
            except Exception as e:
                raise e

            #Flattened database type generation
            dbTargetFileName = dbTypeTargetDir + "/" + fileName
            directory = os.path.dirname(dbTargetFileName)
            if not os.path.exists(directory):
                os.makedirs(directory)

            f = open(dbTargetFileName, "w")
            f.write(produceDatabaseTargetType(goTypeBaseDir + '/' + fileName, typeMetas[fileName.replace('.go', '')]))
            f.close()

            #Service generation
            serviceLines = produceServiceFileForType(tableName, typeMeta)
            serviceFilePath = 'generatedServices/' + tableName + 'Service.go'

            directory = os.path.dirname(serviceFilePath)
            if not os.path.exists(directory):
                os.makedirs(directory)

            f = open(serviceFilePath, 'w')
            f.writelines([i + '\n' for i in serviceLines])
            f.close()

            #DTO generation
            DTOLines = produceDTOForType(tableName, typeMeta)
            DTOFilePath = DTOTargetDir + '/' + tableName + "DTO.go"

            directory = os.path.dirname(DTOFilePath)
            if not os.path.exists(directory):
                os.makedirs(directory)

            f = open(DTOFilePath, 'w')
            f.writelines([i + '\n' for i in DTOLines])
            f.close()

            #Controller generation
            controllerLines = produceControllerFileForType(tableName)
            controllerFilePath = 'generatedControllers/' + tableName + 'Controller.go'
            directory = os.path.dirname(controllerFilePath)
            if not os.path.exists(directory):
                os.makedirs(directory)

            f = open(controllerFilePath, 'w')
            f.writelines([i + '\n' for i in controllerLines])
            f.close()

            #Auto-populated test db values generation
            createStatements.append(produceCreateTableStatement(tableName, typeMeta))
            insertStatements += produceTestInsertStatements(tableName, typeMeta)

            print("Generated backend dependencies for " + tableName + ".")
    
    
    f = open('endpointManagers/generatedEndpointManager.go', 'w')
    f.writelines([i + '\n' for i in generateEndpointManager(tableNames)])
    f.close()

    print("Successfully initialized API endpoints.")

    f = open('testCreates.sql', 'w')
    f.writelines([i + '\n' for i in createStatements])
    f.close()

    f = open('testInserts.sql', 'w')
    f.writelines([i + '\n' for i in insertStatements])
    f.close()

    print("Successfully initialized test SQL.")


#The following expect a dictionary in the return shape specified for produceParsedTypes
def produceCreateTableStatement(tableName: str, typeMeta: dict):

    def generateForeignKeyConstraintSnippet(columnName: str, targetTable: str):
        #The id name is currently locked as 'Id' from generation further up

        return 'CONSTRAINT fk_' + targetTable + ' FOREIGN KEY (' + columnName + ') REFERENCES ' + targetTable + '(Id)'
    
    def generateColumnSnippet(columnName: str, goType: str):
        return columnName + ' ' + goToSqlTypeConversions[goType]

    createTableStatement = 'CREATE TABLE IF NOT EXISTS ' + tableName + '(Id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT'
    
    columnSnippets = []
    constraintSnippets = []

    for attribute in list(typeMeta['attributes'].keys()):
        if (attribute != 'Id'):
            #Id is already added at the front as a special case
            columnSnippets.append(generateColumnSnippet(attribute, typeMeta['attributes'][attribute]['type']))

    for relationship in list(typeMeta['relationships']['manyToOne'].keys()):
        columnSnippets.append(generateColumnSnippet(relationship, typeMeta['relationships']['manyToOne'][relationship]['type']))
        constraintSnippets.append(generateForeignKeyConstraintSnippet(relationship, typeMeta['relationships']['manyToOne'][relationship]['correspondingTable']))

    for snippet in columnSnippets:
        createTableStatement = createTableStatement + ', ' + snippet

    for snippet in constraintSnippets:
        createTableStatement = createTableStatement + ', ' + snippet

    return createTableStatement + ');'


def produceTestInsertStatements(tableName: str, typeMeta: dict):
    
    def getTestTypeDefault(columnName: str, goType: str, numberSeed: int):
        testTypeDefaults = {
            'TEXT': "'" + columnName + ' ' + str(numberSeed) + "'",
            #Number will end up corresponding to booleans (0/1), so we can safely assign this way for test purposes
            'NUMBER': 1,
            'REAL': float(numberSeed),
        }

        return str(testTypeDefaults[goToSqlTypeConversions[goType]])


    def generateInsertStatement(insertSeed: int):
        baseInsertStatement = 'INSERT INTO  ' + tableName + '(' 

        columnOrder = list(typeMeta['attributes'].keys())
        columnOrder.remove("Id")

        relationships = list(typeMeta['relationships']['manyToOne'].keys())

        for column in columnOrder:
            baseInsertStatement += column + (', ' if column != columnOrder[-1] else '')

        for relationship in relationships:
            baseInsertStatement += ', ' + relationship
        
        baseInsertStatement += ') VALUES('

        for column in columnOrder:
                baseInsertStatement += getTestTypeDefault(column, typeMeta['attributes'][column]['type'], insertSeed) + (', ' if column != columnOrder[-1] else '')

        for relationship in relationships:
                baseInsertStatement += ', 1'

        baseInsertStatement += ');'

        return baseInsertStatement
    

    return [generateInsertStatement(i) for i in range(6)]

#Currently assuming full levels of relationship includes
def produceDTOForType(tableName: str, typeMeta: dict):
    dbArgName = 'db'
    objectArgName = tableName[0].lower() + tableName[1:]

    def produceConvertToTableTypeMethod(tableName: str, typeMeta: dict):
        lines = [
            'func ' + tableName + 'DTOTo' + tableName + '(' + objectArgName + ' *' + tableName + 'DTO) types.' + tableName + ' {',
            *indentLineBlock([
                'return types.' + tableName + '{',
                *indentLineBlock([
                    'Id: ' + objectArgName + '.Id,',
                    *[(attribute[0].upper() + attribute[1:] + ': ' + objectArgName + '.Attributes.' + attribute + ',' if attribute != 'Id' else '') for attribute in typeMeta['attributes']],
                    *[relationship[0].upper() + relationship[1:] + ': ' + objectArgName + '.Relationships.ManyToOne.' + relationship + '.Id,' for relationship in typeMeta["relationships"]['manyToOne']],
                ]),
                '}',
            ]),
            '}'
        ]

        return lines
    

    def produceConvertToDTOMethod(tableName: str, typeMeta: dict):
        lines = [
            'func ' + tableName + 'To' + tableName + 'DTO(' + dbArgName + ' *gorm.DB, ' + objectArgName + ' *types.' + tableName + ', traversedTables []string) *' + tableName + 'DTO {',
            *indentLineBlock([
                '',
                'if (slices.Contains(traversedTables, reflect.TypeOf(*' + objectArgName + ').Name())) {',
                *indentLineBlock([
                    'print("Hit circular catch case for table ' + tableName + '\\n")',
                    'return nil'
                ]),
                '}',
                '',
                'traversedTables = append(traversedTables, reflect.TypeOf(*' + objectArgName + ').Name())',
                '',
                *['var included' + relationship + ' types.' + typeMeta['relationships']['manyToOne'][relationship]["correspondingTable"] for relationship in typeMeta["relationships"]['manyToOne']],
                *['var included' + relationship + 's []types.' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] for relationship in typeMeta["relationships"]['oneToMany']],
                '',
                *['services.Get' + typeMeta['relationships']['manyToOne'][relationship]["correspondingTable"] + 'ById(' + dbArgName + ', int(*' + objectArgName + '.' + relationship + '), &included' + relationship + ')' for relationship in typeMeta["relationships"]['manyToOne']],
                *['services.Get' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] + 'sBy' + tableName + 'Id(' + dbArgName + ', int(*' + tableName[0].lower() + tableName[1:] + '.Id),' + ' &included' + relationship + 's)' for relationship in typeMeta["relationships"]['oneToMany']],
                '',
                'return &' + tableName + 'DTO{',
                *indentLineBlock([
                    'Id: ' + objectArgName + '.Id,',
                    'Attributes: ' + tableName + 'DTOAttributes{',
                    *indentLineBlock([(attribute[0].upper() + attribute[1:] + ': ' + objectArgName + '.' + attribute + ',' if attribute != 'Id' else '') for attribute in typeMeta['attributes']]),
                    '},',
                    'Relationships: ' + tableName + 'DTORelationships{',
                    *indentLineBlock([
                        'ManyToOne: ' + tableName + 'DTOManyToOneRelationships {',
                        *indentLineBlock([relationship + ': ' + typeMeta['relationships']['manyToOne'][relationship]["correspondingTable"] + 'To' + typeMeta['relationships']['manyToOne'][relationship]["correspondingTable"] + 'DTO(' + dbArgName + ', &included' + relationship + ', traversedTables),' for relationship in typeMeta["relationships"]['manyToOne']]),
                        '},',
                        'OneToMany: ' + tableName + 'DTOOneToManyRelationships {',
                        *indentLineBlock([relationship + ': utils.Map(included' + relationship + 's, func(relationshipElement types.' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] + ') *' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] + 'DTO { return ' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] + 'To' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] + 'DTO(' + dbArgName + ', &relationshipElement, traversedTables) }),' for relationship in typeMeta["relationships"]['oneToMany']]),
                        '},',
                    ]),
                    '},',
                ]),
                '}',
            ]),
            '}'
        ]

        return lines

    lines = [
        *autogeneratedWarningMessage,
        '',
        'package generatedDTOs',
        '',
        'import (',
        *indentLineBlock([
            'types "AdventureEngineServer/generatedDatabaseTypes"',
            'utils "AdventureEngineServer/utils"' if len(typeMeta["relationships"]["oneToMany"]) > 0 else '',
            'services "AdventureEngineServer/generatedServices"' if len(typeMeta["relationships"]["manyToOne"]) > 0 else '',
  	        '"gorm.io/gorm"',
            '"reflect"',
            '"slices"'
        ]),
        ')',
        '',
        'type ' + tableName + 'DTOAttributes struct {',
        *indentLineBlock([attribute[0].upper() + attribute[1:] + ' ' + typeMeta['attributes'][attribute]['type'] if attribute != 'Id' else '' for attribute in typeMeta['attributes']]),
        '}',
        '',
        'type ' + tableName + 'DTOManyToOneRelationships struct {',
        *indentLineBlock([relationship + ' *' + typeMeta['relationships']['manyToOne'][relationship]["correspondingTable"] + "DTO" for relationship in typeMeta['relationships']['manyToOne']]),
        '}',
        '',
        'type ' + tableName + 'DTOOneToManyRelationships struct {',
        *indentLineBlock([relationship + ' []*' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] + "DTO" for relationship in typeMeta['relationships']['oneToMany']]),
        '}',
        '',
        'type ' + tableName + 'DTORelationships struct {',
        *indentLineBlock([
            'ManyToOne ' + tableName + 'DTOManyToOneRelationships',
            'OneToMany ' + tableName + 'DTOOneToManyRelationships',
        ]),
        '}',
        '',
        'type ' + tableName + 'DTO struct {',
        *indentLineBlock([
            'Id *float64',
            '',
            'Attributes ' + tableName + 'DTOAttributes',
            '',
            'Relationships ' + tableName + 'DTORelationships',
        ]),
        '}',
        '',
        *produceConvertToDTOMethod(tableName, typeMeta),
        '',
        *produceConvertToTableTypeMethod(tableName, typeMeta)
    ]

    return lines


def produceServiceFileForType(tableName: str, typeMeta: dict):

    dbArgName = 'db'
    objectArgName = tableName[0].lower() + tableName[1:]

    def produceServiceSaveMethod(tableName: str):
        lines = [
            'func Save' + tableName + '(' + dbArgName + ' *gorm.DB, ' + objectArgName + ' *types.' + tableName + ') error {',
            *indentLineBlock([
                'tx := ' + dbArgName + '.Begin()',
                '',
                'if tx.Error != nil {',
                    'return errors.New("Could not initialize transaction to save " + reflect.TypeOf(' + objectArgName + ').Name() + " entity")',
                '}',
                '',
                'defer func() {',
                *indentLineBlock([
                    'if r := recover(); r != nil {',
                    '   tx.Rollback()',    
                    '}'
                ]),
                '}()',
                '',
                'if err := tx.Error; err != nil {',
                '   return err',
                '}',
                '',
                'if err := tx.Save(' + objectArgName + ').Error; err != nil {',
                '   tx.Rollback()',
                '   return err',
                '}',
                '',
                'return tx.Commit().Error',
            ]),
            '}'
        ]

        return lines
    

    def produceServiceGetAllMethod(tableName: str):
    
        lines = [
            'func Get' + tableName + 's(' + dbArgName + ' *gorm.DB, ' + objectArgName  + 's *[]types.' + tableName + ') error {',
            *indentLineBlock([
	            'result := db.Table("' + tableName + '").Find(' + objectArgName + 's)',
                'return result.Error',  
            ]),
            '}'
        ]

        return lines


    def produceServiceGetByIdMethod(tableName: str):
    
        lines = [
            'func Get' + tableName + 'ById(' + dbArgName + ' *gorm.DB, id int, ' + objectArgName  + ' *types.' + tableName + ') error {',
            *indentLineBlock([
	            'result := db.Table("' + tableName + '").First(' + objectArgName + ', id)',
                'return result.Error',  
            ]),
            '}'
        ]

        return lines
    
    #This produces getters technically for the opposing table, but this was the most convenient way to do this
    #while being able to determine the reference from the parent type (they will all be imported from the service package anyways)
    def produceServiceGetByFKMethod(tableName: str, relationshipTable: str):

        foreignKeyName = [key for key in list(typeMetas[relationshipTable]['relationships']['manyToOne'].keys()) if typeMetas[relationshipTable]['relationships']['manyToOne'][key]['correspondingTable'] == tableName][0]
    
        lines = [
            'func Get' + relationshipTable + 'sBy' + tableName + 'Id(' + dbArgName + ' *gorm.DB, id int, ' + relationshipTable  + 's *[]types.' + relationshipTable + ') error {',
            *indentLineBlock([
	            'result := db.Table("' + relationshipTable + '").Where(map[string]interface{}{"' + foreignKeyName + '": id}).Find(&' + relationshipTable + 's)',
                'return result.Error',  
            ]),
            '}'
        ]

        return lines
    

    lines = [
        *autogeneratedWarningMessage,
        '',
        'package generatedServices',
        'import (',
        *indentLineBlock([
            '"errors"',
            '"reflect"',
            'types "AdventureEngineServer/generatedDatabaseTypes"',
  	        '"gorm.io/gorm"'
        ]),
        ')',
        '',
        *produceServiceGetAllMethod(tableName),
        '',
        *produceServiceGetByIdMethod(tableName),
        '',
        *produceServiceSaveMethod(tableName),
        '',
        #some code golf here, Python does not take kindly to nested unpacking so we need an extra iteration wrapper
        *[item for sublist in [produceServiceGetByFKMethod(tableName, typeMeta['relationships']['oneToMany'][relationship]['correspondingTable']) for relationship in typeMeta['relationships']['oneToMany']] for item in sublist],
    ]

    return lines


def produceControllerFileForType(tableName: str):

    dbArgName = 'db'
    objectArgName = tableName[0].lower() + tableName[1:]

    def produceControllerGetMethod(tableName: str):
        
        contextArgName = 'ctx'
        objectArgName = tableName[0].lower() + tableName[1:]

        lines = [
            'func Get' + tableName + 's(' + contextArgName + ' *gin.Context, ' + dbArgName + ' *gorm.DB) {',
            *indentLineBlock([
                'var serviceBuffer []types.' + tableName,
                'err := services.Get' + tableName + 's(' + dbArgName + ', &serviceBuffer)',
                'if err != nil {',
                *indentLineBlock([
                    'ctx.IndentedJSON(http.StatusInternalServerError, err.Error())',
                    'return'
                ]),
                '}',
                '',
                'var returnBuffer []dtos.' + tableName + 'DTO',
                'for _, dbTypeInstance := range serviceBuffer {',
                *indentLineBlock([
                    'pointerToDTO := dtos.' + tableName + 'To' + tableName + 'DTO(' + dbArgName + ', &dbTypeInstance, []string{})',
                    'if (pointerToDTO != nil) {',
                    *indentLineBlock([
                        'returnBuffer = append(returnBuffer, *pointerToDTO)'
                    ]),
                    '}'
                ]),
                '}',
                'ctx.IndentedJSON(http.StatusOK, returnBuffer)'
	        ]),
            '}'
        ]

        return lines
    
    def produceControllerGetByIdMethod(tableName: str):
        contextArgName = 'ctx'
        objectArgName = tableName[0].lower() + tableName[1:]

        lines = [
            'func Get' + tableName + 'ById(' + contextArgName + ' *gin.Context, ' + dbArgName + ' *gorm.DB) {',
            *indentLineBlock([
                'id := ctx.Param("id")',
                'idNum, err := strconv.Atoi(id)',
                'if err != nil {',
                *indentLineBlock([
                    contextArgName + '.IndentedJSON(http.StatusInternalServerError, err.Error())',
                    'return'
                ]),
                
                '}',
                'var serviceBuffer types.' + tableName,
                'err = services.Get' + tableName + 'ById(' + dbArgName + ', idNum, &serviceBuffer)',
                'if err != nil {',
                *indentLineBlock([
                    contextArgName + '.IndentedJSON(http.StatusInternalServerError, err.Error())',
                    'return'
                ]),
                '}',
                '',
                'returnBuffer := dtos.' + tableName + 'To' + tableName + 'DTO(' + dbArgName + ', &serviceBuffer, []string{})',
                'ctx.IndentedJSON(http.StatusOK, returnBuffer)'
	        ]),
            '}'
        ]

        return lines

    def produceControllerSaveMethod(tableName: str):
        contextArgName = 'ctx'
        objectArgName = tableName[0].lower() + tableName[1:]

        lines = [
            'func Save' + tableName + '(' + contextArgName + ' *gin.Context, ' + dbArgName + ' *gorm.DB) {',
            *indentLineBlock([
                'var serviceBuffer types.' + tableName,
                'err := services.Save' + tableName + '(' + dbArgName + ', &serviceBuffer)',
                'if err != nil {',
                *indentLineBlock([
                    'ctx.IndentedJSON(http.StatusInternalServerError, err.Error())',
                    'return'
                ]),
                '}',
                '',
                'returnBuffer := dtos.' + tableName + 'To' + tableName + 'DTO(' + dbArgName + ', &serviceBuffer, []string{})',
                'ctx.IndentedJSON(http.StatusOK, returnBuffer)'
	        ]),
            '}'
        ]

        return lines

    lines = [
        *autogeneratedWarningMessage,
        '',
        'package generatedControllers',
        'import (',
        *indentLineBlock([
  	        '"github.com/gin-gonic/gin"',
  	        '"gorm.io/gorm"',
            '"strconv"',
            '"net/http"',
            'services "AdventureEngineServer/generatedServices"',
            'types "AdventureEngineServer/generatedDatabaseTypes"',
            'dtos "AdventureEngineServer/generatedDTOs"'
        ]),
        ')',
        '',
        *produceControllerGetMethod(tableName),
        '',
        *produceControllerGetByIdMethod(tableName),
        '',
        *produceControllerSaveMethod(tableName)
    ]

    return lines


#This requires all tablenames instead of being applied 1 by 1 as it is generating the full file managing all generated table endpoints
def generateEndpointManager(tableNames: list[str]):
    ginContextName = 'router'
    dbContextName = 'db'

    def produceEndpointsForTable(tableName: str):
        lines = [
            'router.GET("/get' + tableName + 's", produceDBContextInjectedEndpoint(' + ginContextName + ', ' + dbContextName + ', controllers.Get' + tableName + 's))',
            'router.GET("/get' + tableName + '/:id", produceDBContextInjectedEndpoint(' + ginContextName + ', ' + dbContextName + ', controllers.Get' + tableName + 'ById))',
            'router.POST("/save' + tableName + '", produceDBContextInjectedEndpoint(' + ginContextName + ', ' + dbContextName + ', controllers.Save' + tableName + '))',
        ]

        return lines

    lines = [
        *autogeneratedWarningMessage,
        '',
        'package endpointManagers',
        'import (',
        *indentLineBlock([
  	        '"github.com/gin-gonic/gin"',
              '"gorm.io/gorm"',
            'controllers "AdventureEngineServer/generatedControllers"'
        ]),
        ')',
        '',
        'func produceDBContextInjectedEndpoint(' + ginContextName + ' *gin.Engine, ' + dbContextName + ' *gorm.DB, endpointHandler func(*gin.Context, *gorm.DB)) gin.HandlerFunc {',
        *indentLineBlock([
            'return func(ctx *gin.Context) {',
		    '   endpointHandler(ctx, ' + dbContextName + ')',
	        '}',
        ]),
        '}',
        '',
        'func ApplyGeneratedEndpoints(' + ginContextName + ' *gin.Engine, ' + dbContextName + ' *gorm.DB) {',
        #A little bit of code golf, as a treat (just unpacking the list of lists of generated lines since Python doesn't like embedding * syntax in here)
        *indentLineBlock([item for sublist in [produceEndpointsForTable(tableName) for tableName in tableNames] for item in sublist]),
        '}'
    ]

    return lines

if __name__ == '__main__': main()