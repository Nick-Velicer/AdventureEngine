import os
import re
import pprint
from utils.utils import produceDatabaseTargetType, produceParsedType, goToSqlTypeConversions

goTypeBaseDir = './goTypeBase'
dbTypeTargetDir = './generatedDatabaseTypes'
DTOTargetDir = './generatedDTOs'

autogeneratedWarningMessage = [
    '//*** CAUTION ***',
    '//This is an autogenerated file produced by regenerateBackend.py.',
    '//Edits made here will not persist after backend regeneration.',
]

#global context used for cross-service type reaching
typeMetas = {}

def indentLineBlock(lines: list):
    return ['   ' + line for line in lines]


def main():
    goTypeBaseDirectory = os.fsencode(goTypeBaseDir)

    dbTargetDir = os.path.dirname(dbTypeTargetDir)
    if not os.path.exists(dbTargetDir):
        os.makedirs(dbTargetDir)

    #Parsing types and adding results to the global context
    for file in os.listdir(goTypeBaseDirectory):
        fileName = os.fsdecode(file)

        if fileName.endswith('.go'): 
            tableName = fileName.replace('.go', '')

            try:
                typeMetas[tableName] = produceParsedType(goTypeBaseDir + '/' + fileName)
            except Exception as e:
                raise e

    print("Go types successfully parsed.")

    #Primary file generation for services, DTOs, SQL, and endpoint setup
    createStatements = []
    insertStatements = []
    tableNames = []

    for file in os.listdir(goTypeBaseDirectory):
        fileName = os.fsdecode(file)

        if fileName.endswith('.go'): 
            tableName = fileName.replace('.go', '')
            tableNames.append(tableName)
            typeMeta = typeMetas[tableName]

            try:
                typeMeta = produceParsedType(goTypeBaseDir + '/' + fileName)
                
            except Exception as e:
                raise e

            #Flattened database type generation
            dbTargetFileName = dbTypeTargetDir + "/" + fileName
            directory = os.path.dirname(dbTargetFileName)
            if not os.path.exists(directory):
                os.makedirs(directory)

            f = open(dbTargetFileName, "w")
            f.write(produceDatabaseTargetType(goTypeBaseDir + '/' + fileName, typeMetas[fileName.replace('.go', '')]))
            f.close()

            #Service generation
            serviceLines = produceServiceFileForType(tableName, typeMeta)
            serviceFilePath = 'generatedServices/' + tableName + 'Service.go'

            directory = os.path.dirname(serviceFilePath)
            if not os.path.exists(directory):
                os.makedirs(directory)

            f = open(serviceFilePath, 'w')
            f.writelines([i + '\n' for i in serviceLines])
            f.close()

            #DTO generation
            DTOLines = produceDTOForType(tableName, typeMeta)
            DTOFilePath = DTOTargetDir + '/' + tableName + "DTO.go"

            directory = os.path.dirname(DTOFilePath)
            if not os.path.exists(directory):
                os.makedirs(directory)

            f = open(DTOFilePath, 'w')
            f.writelines([i + '\n' for i in DTOLines])
            f.close()

            #Controller generation
            controllerLines = produceControllerFileForType(tableName)
            controllerFilePath = 'generatedControllers/' + tableName + 'Controller.go'
            directory = os.path.dirname(controllerFilePath)
            if not os.path.exists(directory):
                os.makedirs(directory)

            f = open(controllerFilePath, 'w')
            f.writelines([i + '\n' for i in controllerLines])
            f.close()

            #Auto-populated test db values generation
            createStatements.append(produceCreateTableStatement(tableName, typeMeta))
            insertStatements += produceTestInsertStatements(tableName, typeMeta)

            print("Generated backend dependencies for " + tableName + ".")
    
    
    f = open('endpointManagers/generatedEndpointManager.go', 'w')
    f.writelines([i + '\n' for i in generateEndpointManager(tableNames)])
    f.close()

    print("Successfully initialized API endpoints.")

    f = open('testCreates.sql', 'w')
    f.writelines([i + '\n' for i in createStatements])
    f.close()

    f = open('testInserts.sql', 'w')
    f.writelines([i + '\n' for i in insertStatements])
    f.close()

    print("Successfully initialized test SQL.")


#The following expect a dictionary in the return shape specified for produceParsedTypes
def produceCreateTableStatement(tableName: str, typeMeta: dict):
    
    def generateForeignKeyConstraintSnippet(columnName: str, targetTable: str):
        #The id name is currently locked as 'Id' from generation further up

        return 'CONSTRAINT fk_' + targetTable + ' FOREIGN KEY (' + columnName + ') REFERENCES ' + targetTable + '(Id)'
    
    def generateColumnSnippet(columnName: str, goType: str):
        return columnName + ' ' + goToSqlTypeConversions[goType]

    createTableStatement = 'CREATE TABLE IF NOT EXISTS ' + tableName + '(Id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT'
    
    columnSnippets = []
    constraintSnippets = []

    for attribute in list(typeMeta['attributes'].keys()):
        if (attribute != 'Id'):
            #Id is already added at the front as a special case
            columnSnippets.append(generateColumnSnippet(attribute, typeMeta['attributes'][attribute]['type']))

    for relationship in list(typeMeta['relationships']['manyToOne'].keys()):
        columnSnippets.append(generateColumnSnippet(relationship, typeMeta['relationships']['manyToOne'][relationship]['type']))
        constraintSnippets.append(generateForeignKeyConstraintSnippet(relationship, typeMeta['relationships']['manyToOne'][relationship]['correspondingTable']))

    for snippet in columnSnippets:
        createTableStatement = createTableStatement + ', ' + snippet

    for snippet in constraintSnippets:
        createTableStatement = createTableStatement + ', ' + snippet

    return createTableStatement + ');'


def produceTestInsertStatements(tableName: str, typeMeta: dict):
    
    def getTestTypeDefault(columnName: str, goType: str, numberSeed: int):
        testTypeDefaults = {
            'TEXT': "'" + columnName + ' ' + str(numberSeed) + "'",
            #Number will end up corresponding to booleans (0/1), so we can safely assign this way for test purposes
            'NUMBER': 1,
            'REAL': float(numberSeed),
        }

        return str(testTypeDefaults[goToSqlTypeConversions[goType]])


    def generateInsertStatement(insertSeed: int):
        baseInsertStatement = 'INSERT INTO  ' + tableName + '(' 

        columnOrder = list(typeMeta['attributes'].keys())
        columnOrder.remove("Id")

        relationships = list(typeMeta['relationships']['manyToOne'].keys())

        for column in columnOrder:
            baseInsertStatement += column + (', ' if column != columnOrder[-1] else '')

        for relationship in relationships:
            baseInsertStatement += ', ' + relationship
        
        baseInsertStatement += ') VALUES('

        for column in columnOrder:
                baseInsertStatement += getTestTypeDefault(column, typeMeta['attributes'][column]['type'], insertSeed) + (', ' if column != columnOrder[-1] else '')

        for relationship in relationships:
                baseInsertStatement += ', 1'

        baseInsertStatement += ');'

        return baseInsertStatement
    

    return [generateInsertStatement(i) for i in range(6)]

#Currently assuming full levels of relationship includes
def produceDTOForType(tableName: str, typeMeta: dict):
    dbArgName = 'db'
    objectArgName = tableName[0].lower() + tableName[1:]

    def produceConvertToTableTypeMethod(tableName: str, typeMeta: dict):
        lines = [
            'func ' + tableName + 'DTOTo' + tableName + '(' + objectArgName + ' *' + tableName + 'DTO) *types.' + tableName + ' {',
            *indentLineBlock([
                'var tableTypeBuffer types.' + tableName,
                '',
                'tableTypeBuffer.Id = ' + objectArgName + '.Id',
                *[('tableTypeBuffer.' + (attribute[0].upper() + attribute[1:] + ' = ' + objectArgName + '.Attributes.' + attribute + '') if attribute != 'Id' else '') for attribute in typeMeta['attributes']],
                '',
                *[
                    #Not technically using the indentLineBlock convention, but python doesn't like the extra inner looping/unpacking so this is relatively a reasonable tradeoff
                    'if (' + objectArgName + '.Relationships.ManyToOne.' + relationship + ' != nil) {\n' +
                    '      tableTypeBuffer.' + relationship + ' = ' + objectArgName + '.Relationships.ManyToOne.' + relationship + '.Id\n' + 
                    '   }\n'
                    for relationship in typeMeta["relationships"]['manyToOne']
                ],
                'return &tableTypeBuffer'
            ]),
            '}'
        ]

        return lines
    

    def produceConvertToDTOMethod(tableName: str, typeMeta: dict):
        lines = [
            'func ' + tableName + 'To' + tableName + 'DTO(' + dbArgName + ' *gorm.DB, ' + objectArgName + ' *types.' + tableName + ', traversedTables []string) *' + tableName + 'DTO {',
            *indentLineBlock([
                '',
                'if (' + objectArgName + ' == nil) {',
                *indentLineBlock([
                    'fmt.Println("Nil pointer passed to DTO conversion for table ' + tableName + '")',
                    'return nil'
                ]),
                '}',
                '',
                'if (slices.Contains(traversedTables, reflect.TypeOf(*' + objectArgName + ').Name())) {',
                *indentLineBlock([
                    'fmt.Println("Hit circular catch case for table ' + tableName + '")',
                    'return nil'
                ]),
                '}',
                '',
                'traversedTables = append(traversedTables, reflect.TypeOf(*' + objectArgName + ').Name())',
                '',
                *['var included' + relationship + ' types.' + typeMeta['relationships']['manyToOne'][relationship]["correspondingTable"] for relationship in typeMeta["relationships"]['manyToOne']],
                *['var included' + relationship + 's []types.' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] for relationship in typeMeta["relationships"]['oneToMany']],
                '',
                *[
                    #Not technically using the indentLineBlock convention, but python doesn't like the extra inner looping/unpacking so this is relatively a reasonable tradeoff
                    'if (' + objectArgName + '.' + relationship + ' != nil) {\n' +
                    '      if err := services.Get' + typeMeta['relationships']['manyToOne'][relationship]["correspondingTable"] + 'ById(' + dbArgName + ', int(*' + objectArgName + '.' + relationship + '), &included' + relationship + '); err != nil {\n'  +
                    '         fmt.Println("Error fetching many-to-one table ' + typeMeta['relationships']['manyToOne'][relationship]["correspondingTable"] + ':")\n' + 
                    '         fmt.Println(err)\n' + 
                    '      }\n' +
                    '   }\n'
                    for relationship in typeMeta["relationships"]['manyToOne']
                ],
                *[
                    'if (slices.Contains(traversedTables, reflect.TypeOf(included' + relationship + 's).Elem().Name())) {\n' +
                    '      included' + relationship + 's = []types.' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] + '{}\n' +
                    '      fmt.Println("Hit circular catch case for table ' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] + '")\n' +
                    '   } else {\n' +
                    '      services.Get' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] + 'sBy' + tableName + 'Id(' + dbArgName + ', int(*' + tableName[0].lower() + tableName[1:] + '.Id),' + ' &included' + relationship + 's)\n'  +
                    '   }\n'
                    for relationship in typeMeta["relationships"]['oneToMany']
                ],
                '',
                'return &' + tableName + 'DTO{',
                *indentLineBlock([
                    'Id: ' + objectArgName + '.Id,',
                    'Attributes: ' + tableName + 'DTOAttributes{',
                    *indentLineBlock([(attribute[0].upper() + attribute[1:] + ': ' + objectArgName + '.' + attribute + ',' if attribute == 'Password' else (attribute[0].upper() + attribute[1:] + ': ' + objectArgName + '.' + attribute + ',' if attribute != 'Id' else '')) for attribute in typeMeta['attributes']]),
                    '},',
                    'Relationships: ' + tableName + 'DTORelationships{',
                    *indentLineBlock([
                        'ManyToOne: ' + tableName + 'DTOManyToOneRelationships {',
                        *indentLineBlock([relationship + ': ' + typeMeta['relationships']['manyToOne'][relationship]["correspondingTable"] + 'To' + typeMeta['relationships']['manyToOne'][relationship]["correspondingTable"] + 'DTO(' + dbArgName + ', &included' + relationship + ', traversedTables),' for relationship in typeMeta["relationships"]['manyToOne']]),
                        '},',
                        'OneToMany: ' + tableName + 'DTOOneToManyRelationships {',
                        *indentLineBlock([relationship + ': utils.Map(included' + relationship + 's, func(relationshipElement types.' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] + ') *' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] + 'DTO { return ' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] + 'To' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] + 'DTO(' + dbArgName + ', &relationshipElement, traversedTables) }),' for relationship in typeMeta["relationships"]['oneToMany']]),
                        '},',
                    ]),
                    '},',
                ]),
                '}',
            ]),
            '}'
        ]

        return lines

    lines = [
        *autogeneratedWarningMessage,
        '',
        'package generatedDTOs',
        '',
        'import (',
        *indentLineBlock([
            'types "AdventureEngineServer/generatedDatabaseTypes"',
            'utils "AdventureEngineServer/utils"' if len(typeMeta["relationships"]["oneToMany"]) > 0 else '',
            'services "AdventureEngineServer/generatedServices"' if len(typeMeta["relationships"]["manyToOne"]) > 0 or len(typeMeta["relationships"]["oneToMany"]) > 0 else '',
  	        '"gorm.io/gorm"',
            '"fmt"',
            '"reflect"',
            '"slices"',
        ]),
        ')',
        '',
        'type ' + tableName + 'DTOAttributes struct {',
        *indentLineBlock([attribute[0].upper() + attribute[1:] + ' ' + typeMeta['attributes'][attribute]['type'] if attribute != 'Id' else '' for attribute in typeMeta['attributes']]),
        '}',
        '',
        'type ' + tableName + 'DTOManyToOneRelationships struct {',
        *indentLineBlock([relationship + ' *' + typeMeta['relationships']['manyToOne'][relationship]["correspondingTable"] + "DTO" for relationship in typeMeta['relationships']['manyToOne']]),
        '}',
        '',
        'type ' + tableName + 'DTOOneToManyRelationships struct {',
        *indentLineBlock([relationship + ' []*' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] + "DTO" for relationship in typeMeta['relationships']['oneToMany']]),
        '}',
        '',
        'type ' + tableName + 'DTORelationships struct {',
        *indentLineBlock([
            'ManyToOne ' + tableName + 'DTOManyToOneRelationships',
            'OneToMany ' + tableName + 'DTOOneToManyRelationships',
        ]),
        '}',
        '',
        'type ' + tableName + 'DTO struct {',
        *indentLineBlock([
            'Id *int',
            '',
            'Attributes ' + tableName + 'DTOAttributes',
            '',
            'Relationships ' + tableName + 'DTORelationships',
        ]),
        '}',
        '',
        *produceConvertToDTOMethod(tableName, typeMeta),
        '',
        *produceConvertToTableTypeMethod(tableName, typeMeta)
    ]

    return lines


def produceServiceFileForType(tableName: str, typeMeta: dict):

    dbArgName = 'db'
    objectArgName = tableName[0].lower() + tableName[1:]

    def produceServiceSaveMethod(tableName: str):
        lines = [
            'func Save' + tableName + '(' + dbArgName + ' *gorm.DB, ' + objectArgName + 's []*types.' + tableName + ') error {',
            *indentLineBlock([
                'tx := ' + dbArgName + '.Begin()',
                '',
                'if tx.Error != nil {',
                *indentLineBlock([
                    'return errors.New("Could not initialize transaction to save " + reflect.TypeOf(' + objectArgName + 's).Name() + " entity")',
                ]), 
                '}',
                '',
                'defer func() {',
                *indentLineBlock([
                    'if r := recover(); r != nil {',
                    *indentLineBlock([
                        'tx.Rollback()'
                    ]),  
                    '}'
                ]),
                '}()',
                '',
                'if err := tx.Error; err != nil {',
                *indentLineBlock([
                    'return err',
                ]),
                '}',
                '',
                'if err := tx.Table("' + tableName + '").Save(' + objectArgName + 's).Error; err != nil {',
                *indentLineBlock([
                    'tx.Rollback()',
                    'return err',
                ]),
                '}',
                '',
                'return tx.Commit().Error',
            ]),
            '}'
        ]

        return lines
    

    def produceServiceGetAllMethod(tableName: str):
    
        lines = [
            'func Get' + tableName + 's(' + dbArgName + ' *gorm.DB, ' + objectArgName  + 's *[]types.' + tableName + ', filters *[]utils.FilterExpression) error {',
            *indentLineBlock([
                'filteredContext, err := utils.FilterTableContext(db.Table("' + tableName + '"), filters)',
                'if err != nil {',
                *indentLineBlock([
                    'return err',
                ]),
                '}',
	            'result := filteredContext.Find(' + objectArgName + 's)',
                'return result.Error',  
            ]),
            '}'
        ]

        return lines


    def produceServiceGetByIdMethod(tableName: str):
    
        lines = [
            'func Get' + tableName + 'ById(' + dbArgName + ' *gorm.DB, id int, ' + objectArgName  + ' *types.' + tableName + ') error {',
            *indentLineBlock([
	            'result := db.Table("' + tableName + '").First(' + objectArgName + ', id)',
                'return result.Error',  
            ]),
            '}'
        ]

        return lines
    
    #This produces getters technically for the opposing table, but this was the most convenient way to do this
    #while being able to determine the reference from the parent type (they will all be imported from the service package anyways)
    def produceServiceGetByFKMethod(tableName: str, relationshipTable: str):

        filteredForeignKeys = [key for key in list(typeMetas[relationshipTable]['relationships']['manyToOne'].keys()) if typeMetas[relationshipTable]['relationships']['manyToOne'][key]['correspondingTable'] == tableName]

        if len(filteredForeignKeys) == 0:
            return []

        foreignKeyName = filteredForeignKeys[0]
    
        lines = [
            'func Get' + relationshipTable + 'sBy' + tableName + 'Id(' + dbArgName + ' *gorm.DB, id int, ' + relationshipTable  + 's *[]types.' + relationshipTable + ') error {',
            *indentLineBlock([
	            'result := db.Table("' + relationshipTable + '").Where(map[string]interface{}{"' + foreignKeyName + '": id}).Find(' + relationshipTable + 's)',
                'return result.Error',  
            ]),
            '}'
        ]

        return lines
    

    lines = [
        *autogeneratedWarningMessage,
        '',
        'package generatedServices',
        'import (',
        *indentLineBlock([
            '"errors"',
  	        '"gorm.io/gorm"',
            '"reflect"',
            'types "AdventureEngineServer/generatedDatabaseTypes"',
            'utils "AdventureEngineServer/utils"'
        ]),
        ')',
        '',
        *produceServiceGetAllMethod(tableName),
        '',
        *produceServiceGetByIdMethod(tableName),
        '',
        *produceServiceSaveMethod(tableName),
        '',
        #some code golf here, Python does not take kindly to nested unpacking so we need an extra iteration wrapper
        *[item for sublist in [produceServiceGetByFKMethod(tableName, typeMeta['relationships']['oneToMany'][relationship]['correspondingTable']) for relationship in typeMeta['relationships']['oneToMany']] for item in sublist],
    ]

    return lines


def produceControllerFileForType(tableName: str):

    dbArgName = 'db'
    objectArgName = tableName[0].lower() + tableName[1:]

    def produceControllerGetMethod(tableName: str):
        
        contextArgName = 'ctx'
        objectArgName = tableName[0].lower() + tableName[1:]

        lines = [
            'func Get' + tableName + 's(' + contextArgName + ' *gin.Context, ' + dbArgName + ' *gorm.DB) {',
            *indentLineBlock([
                'queryParams := ' + contextArgName + '.Request.URL.Query()',
                '',
                '//Since we can have multiple filters, that sometimes doesn\'t play nicely with',
                '//Gin\'s parameter pulling, so they need to be isolated manually.',
                're := regexp.MustCompile(`filter\\[`)',
                'filterParams := make(map[string]string)',
                'for key, value := range queryParams {',
                *indentLineBlock([
                    'if re.MatchString(key) && len(value) == 1 {',
                    *indentLineBlock([
                        'filterParams[key] = value[0]'
                    ]),
                    '} else {',
                    *indentLineBlock([
                        'fmt.Println("Unexpected filter configuration for " + key + ", skipping:")',
                        'fmt.Println(value)'
                    ]),
                    '}'
                ]),
                '}',
                '',
                'parsedFilters := utils.ParseFilterURLExpression(filterParams)',
                '',
                'var serviceBuffer []types.' + tableName,
                'err := services.Get' + tableName + 's(' + dbArgName + ', &serviceBuffer, &parsedFilters)',
                'if err != nil {',
                *indentLineBlock([
                    'ctx.IndentedJSON(http.StatusInternalServerError, err.Error())',
                    'return'
                ]),
                '}',
                '',
                'var returnBuffer []dtos.' + tableName + 'DTO',
                'for _, dbTypeInstance := range serviceBuffer {',
                *indentLineBlock([
                    'pointerToDTO := dtos.' + tableName + 'To' + tableName + 'DTO(' + dbArgName + ', &dbTypeInstance, []string{})',
                    'if (pointerToDTO != nil) {',
                    *indentLineBlock([
                        'returnBuffer = append(returnBuffer, *pointerToDTO)'
                    ]),
                    '}'
                ]),
                '}',
                'ctx.IndentedJSON(http.StatusOK, returnBuffer)'
	        ]),
            '}'
        ]

        return lines
    
    def produceControllerGetByIdMethod(tableName: str):
        contextArgName = 'ctx'
        objectArgName = tableName[0].lower() + tableName[1:]

        lines = [
            'func Get' + tableName + 'ById(' + contextArgName + ' *gin.Context, ' + dbArgName + ' *gorm.DB) {',
            *indentLineBlock([
                'id := ctx.Param("id")',
                'idNum, err := strconv.Atoi(id)',
                'if err != nil {',
                *indentLineBlock([
                    contextArgName + '.IndentedJSON(http.StatusInternalServerError, err.Error())',
                    'return'
                ]),
                
                '}',
                'var serviceBuffer types.' + tableName,
                'err = services.Get' + tableName + 'ById(' + dbArgName + ', idNum, &serviceBuffer)',
                'if err != nil {',
                *indentLineBlock([
                    contextArgName + '.IndentedJSON(http.StatusInternalServerError, err.Error())',
                    'return'
                ]),
                '}',
                '',
                'returnBuffer := dtos.' + tableName + 'To' + tableName + 'DTO(' + dbArgName + ', &serviceBuffer, []string{})',
                'ctx.IndentedJSON(http.StatusOK, returnBuffer)'
	        ]),
            '}'
        ]

        return lines

    def produceControllerSaveMethod(tableName: str):
        contextArgName = 'ctx'
        objectArgName = tableName[0].lower() + tableName[1:]

        lines = [
            'func Save' + tableName + '(' + contextArgName + ' *gin.Context, ' + dbArgName + ' *gorm.DB) {',
            *indentLineBlock([
                '//Weirdness with unmarshalling, cannot unmarshal into a nil pointer, there must be some pre-initialization somewhere along the line',
                'var DTOBuffer *dtos.' + tableName + 'DTO = &dtos.' + tableName + 'DTO{}',
                'var batchDTOBuffer []*dtos.' + tableName + 'DTO',
                'var serviceBuffer []*types.' + tableName,
                '',
                '//If neither a single item nor a collection can be bound to JSON, fail early',
                '//ShouldBindBodyWith is used instead of ShouldBindJSON since the latter prevents multiple bind attempts',
                'if err := ctx.ShouldBindBodyWith(DTOBuffer, binding.JSON); err == nil {',
                *indentLineBlock([
                    '',
                    'serviceBuffer = []*types.' + tableName + '{dtos.' + tableName + 'DTOTo' + tableName + '(DTOBuffer)}',
                    'if err := services.Save' + tableName + '(' + dbArgName + ', serviceBuffer); err != nil {',
                    *indentLineBlock([
                        'ctx.IndentedJSON(http.StatusInternalServerError, err.Error())',
                        'return'
                    ]),
                    '}',
                    '',
                    'returnBuffer := dtos.' + tableName + 'To' + tableName + 'DTO(' + dbArgName + ', serviceBuffer[0], []string{})',
                    '',
                    'ctx.IndentedJSON(http.StatusOK, returnBuffer)',
                    'return',
                    ''
                ]),
                '} else if err := ctx.ShouldBindBodyWith(&batchDTOBuffer, binding.JSON); err == nil {',
                *indentLineBlock([
                    '',
                    'serviceBuffer = utils.Map(batchDTOBuffer, func(dto *dtos.' + tableName + 'DTO) *types.' + tableName + ' { return dtos.' + tableName + 'DTOTo' + tableName + '(dto) })',
                    'if err := services.Save' + tableName + '(' + dbArgName + ', serviceBuffer); err != nil {',
                    *indentLineBlock([
                        'ctx.IndentedJSON(http.StatusInternalServerError, err.Error())',
                        'return'
                    ]),
                    '}',
                    '',
                    'returnBuffer := utils.Map(serviceBuffer, func(dbReturn *types.' + tableName + ') *dtos.' + tableName + 'DTO { return dtos.' + tableName + 'To' + tableName + 'DTO(' + dbArgName + ', dbReturn, []string{}) })',
                    '',
                    'ctx.IndentedJSON(http.StatusOK, returnBuffer)',
                    'return',
                    ''
                ]),
                '} else {',
                *indentLineBlock([
                    'ctx.IndentedJSON(http.StatusBadRequest, err.Error())',
                    'return'
                ]),
                '}',
	        ]),
            '}'
        ]

        return lines

    lines = [
        *autogeneratedWarningMessage,
        '',
        'package generatedControllers',
        'import (',
        *indentLineBlock([
            '"fmt"',
  	        '"github.com/gin-gonic/gin"',
            '"github.com/gin-gonic/gin/binding"',
  	        '"gorm.io/gorm"',
            '"net/http"',
            '"regexp"',
            '"strconv"',
            'services "AdventureEngineServer/generatedServices"',
            'types "AdventureEngineServer/generatedDatabaseTypes"',
            'dtos "AdventureEngineServer/generatedDTOs"',
            'utils "AdventureEngineServer/utils"',
        ]),
        ')',
        '',
        *produceControllerGetMethod(tableName),
        '',
        *produceControllerGetByIdMethod(tableName),
        '',
        *produceControllerSaveMethod(tableName)
    ]

    return lines


#This requires all tablenames instead of being applied 1 by 1 as it is generating the full file managing all generated table endpoints
def generateEndpointManager(tableNames: list[str]):

    #Preventing the user endpoints from being exposed, the CRUD workflow for those will be handled by custom endpoints
    tableNames.remove("User")

    ginContextName = 'router'
    dbContextName = 'db'

    def produceEndpointsForTable(tableName: str):
        lines = [
            'router.GET("/get' + tableName + 's", ProduceDBContextInjectedEndpoint(' + ginContextName + ', ' + dbContextName + ', controllers.Get' + tableName + 's))',
            'router.GET("/get' + tableName + '/:id", ProduceDBContextInjectedEndpoint(' + ginContextName + ', ' + dbContextName + ', controllers.Get' + tableName + 'ById))',
            'router.POST("/save' + tableName + '", ProduceDBContextInjectedEndpoint(' + ginContextName + ', ' + dbContextName + ', controllers.Save' + tableName + '))',
        ]

        return lines

    lines = [
        *autogeneratedWarningMessage,
        '',
        'package endpointManagers',
        'import (',
        *indentLineBlock([
  	        '"github.com/gin-gonic/gin"',
              '"gorm.io/gorm"',
            'controllers "AdventureEngineServer/generatedControllers"'
        ]),
        ')',
        '',
        'func ProduceDBContextInjectedEndpoint(' + ginContextName + ' *gin.Engine, ' + dbContextName + ' *gorm.DB, endpointHandler func(*gin.Context, *gorm.DB)) gin.HandlerFunc {',
        *indentLineBlock([
            'return func(ctx *gin.Context) {',
		    '   endpointHandler(ctx, ' + dbContextName + ')',
	        '}',
        ]),
        '}',
        '',
        'func ApplyGeneratedEndpoints(' + ginContextName + ' *gin.Engine, ' + dbContextName + ' *gorm.DB) {',
        #A little bit of code golf, as a treat (just unpacking the list of lists of generated lines since Python doesn't like embedding * syntax in here)
        *indentLineBlock([item for sublist in [produceEndpointsForTable(tableName) for tableName in tableNames] for item in sublist]),
        '}'
    ]

    return lines

if __name__ == '__main__': main()