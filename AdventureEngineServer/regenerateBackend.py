import os
import re
import pprint

goTypeBaseDir = './goTypeBase'
dbTypeTargetDir = './generatedDatabaseTypes'
DTOTargetDir = './generatedDTOs'

goToSqlTypeConversions = {
    'string': 'TEXT',
    '*string': 'TEXT',
    'bool': 'NUMBER',
    '*bool': 'NUMBER',
    '*float64': 'REAL',
    'float64' : 'REAL'
}

autogeneratedWarningMessage = [
    '//*** CAUTION ***',
    '//This is an autogenerated file produced by regenerateBackend.py.',
    '//Edits made here will not persist after backend regeneration.',
]

def indentLineBlock(lines: list):
        return ['   ' + line for line in lines]


def main():
    goTypeBaseDirectory = os.fsencode(goTypeBaseDir)

    dbTargetDir = os.path.dirname(dbTypeTargetDir)
    if not os.path.exists(dbTargetDir):
        os.makedirs(dbTargetDir)
    
    for goTypeSeedFile in os.listdir(goTypeBaseDirectory):
        fileName = os.fsdecode(goTypeSeedFile)
        if fileName.endswith('.go'): 
            targetFileName = dbTypeTargetDir + "/" + fileName
            directory = os.path.dirname(targetFileName)
            if not os.path.exists(directory):
                os.makedirs(directory)

            f = open(targetFileName, "w")
            f.write(produceDatabaseTargetType(goTypeBaseDir + '/' + fileName))
            f.close()


    createStatements = []
    insertStatements = []
    tableNames = []

    for file in os.listdir(dbTypeTargetDir + "/"):
        fileName = os.fsdecode(file)

        if fileName.endswith('.go'): 
            tableName = fileName.replace('.go', '')
            tableNames.append(tableName)
            typeMeta = {}

            try:
                typeMeta = produceParsedType(dbTypeTargetDir + '/' + fileName)

            except Exception as e:
                raise e
            
            createStatements.append(produceCreateTableStatement(tableName, typeMeta))
            insertStatements += produceTestInsertStatements(tableName, typeMeta)

            serviceLines = produceServiceFileForType(tableName, typeMeta)
            serviceFilePath = 'generatedServices/' + tableName + 'Service.go'

            DTOLines = produceDTOForType(tableName, typeMeta)
            DTOFilePath = DTOTargetDir + '/' + tableName + "DTO.go"

            directory = os.path.dirname(DTOFilePath)
            if not os.path.exists(directory):
                os.makedirs(directory)

            f = open(DTOFilePath, 'w')
            f.writelines([i + '\n' for i in DTOLines])
            f.close()

            directory = os.path.dirname(serviceFilePath)
            if not os.path.exists(directory):
                os.makedirs(directory)

            f = open(serviceFilePath, 'w')
            f.writelines([i + '\n' for i in serviceLines])
            f.close()

            controllerLines = produceControllerFileForType(tableName)
            controllerFilePath = 'generatedControllers/' + tableName + 'Controller.go'
            directory = os.path.dirname(controllerFilePath)
            if not os.path.exists(directory):
                os.makedirs(directory)

            f = open(controllerFilePath, 'w')
            f.writelines([i + '\n' for i in controllerLines])
            f.close()
    
    
    f = open('endpointManagers/generatedEndpointManager.go', 'w')
    f.writelines([i + '\n' for i in generateEndpointManager(tableNames)])
    f.close()

    f = open('testCreates.sql', 'w')
    f.writelines([i + '\n' for i in createStatements])
    f.close()

    f = open('testInserts.sql', 'w')
    f.writelines([i + '\n' for i in insertStatements])
    f.close()


def produceParsedType(fileName: str):
    fileContent = ''

    try:
        with open(fileName, 'r', encoding='utf-8') as file:
            fileContent = file.read()

    except FileNotFoundError:
        raise FileNotFoundError('Error: The file ' + fileName + ' was not found.')
    
    except Exception as e:
        raise e
    
    if (fileContent == ''):
        raise Exception('Unexpected: could not recieve file content from ' + fileName)

    #Isolating the main key/value content
    fileContent = fileContent.split('{', 1)[1].split('}', 1)[0]

    #Removing comment lines
    fileContent = re.sub('//(.+)\n', '', fileContent)

    #Removing any additional JSON annotation wrapped like `some annotation`
    #fileContent = re.sub('`[^`]+`', '', fileContent)

    #Trimming newlines and tabs, and isolating field names and types to their own cleaned dictionary
    fileContent = re.sub('\n\n', '\n', fileContent)
    fileContent = re.sub('\t', '', fileContent)

    fileContent = fileContent.split('\n')
    fileContent = [i.strip() for i in fileContent if i != '']
    fileContent = [i.split(' ', 1) for i in fileContent]

    fieldTypes = {
        'attributes': {}, 
        'relationships': {
            'manyToOne': {},
            'oneToMany': {}
        }
    }

    #Checking for relationship-specific delimiters to know which fields are foreign keys
    #and removing the `json annotation` containing said delimiter afterwards
    for field in fileContent:
        if ( '__' not in field[1]):
            fieldTypes['attributes'][field[0]] = {'type': re.sub('`[^`]+`', '', field[1]).strip()}
        else:
            if ('[]' in field[1]):
                correspondingTableText: str = re.findall(r'(\w*%s\w*)' % '__', field[1])[0].split('__')[1]

                fieldTypes['relationships']['oneToMany'][field[0]] = {
                    'type': re.sub('`[^`]+`', '', field[1]).strip(),
                    #There's not a convenient way to do this any more inline, .capitalize() lowercases all the other characters
                    'correspondingTable': correspondingTableText[0].upper() + correspondingTableText[1:]
                }
            else:
                correspondingTableText: str = re.findall(r'(\w*%s\w*)' % '__', field[1])[0].split('__')[1]

                fieldTypes['relationships']['manyToOne'][field[0]] = {
                    'type': re.sub('`[^`]+`', '', field[1]).strip(),
                    'correspondingTable': correspondingTableText[0].upper() + correspondingTableText[1:]
                }

    #resulting dict structure for a type/table:
    #{
    #   'attributes': {
    #       'field': {
    #           'type': 'type'
    #       }
    #   }
    #
    #   'relationships': {
    #       'oneToMany': {
    #           'field': {
    #             'type': 'type'
    #             'correspondingTable': 'tableName'
    #            }
    #       }
    #       'manyToOne': {
    #           'field': {
    #             'type': 'type'
    #             'correspondingTable': 'tableName'
    #            }
    #       }
    #       
    #   }
    #}
    return fieldTypes


def produceDatabaseTargetType(fileName: str):
    
    #For now, outputting a new file without the JSON in the name for the db-compatible type
    #Any additional transformations for the database interfaces can be intialized here
    fileContent = ''

    try:
        with open(fileName, 'r', encoding='utf-8') as file:
            fileContent = file.read()

    except FileNotFoundError:
        raise FileNotFoundError('Error: The file ' + fileName + ' was not found.')
    
    except Exception as e:
        raise e

    if (fileContent == ''):
        raise Exception('Unexpected: could not recieve file content from ' + fileName)
    
    fileContent = "\n".join([line for line in fileContent.split("\n") if not ('[]' in line)])


    return fileContent.replace("Json", "").replace("goTypeBase", "generatedDatabaseTypes")


#The following expect a dictionary in the return shape specified for produceParsedTypes
def produceCreateTableStatement(tableName: str, typeMeta: dict):

    def generateForeignKeyConstraintSnippet(columnName: str, targetTable: str):
        #The id name is currently locked as 'Id' from generation further up

        return 'CONSTRAINT fk_' + targetTable + ' FOREIGN KEY (' + columnName + ') REFERENCES ' + targetTable + '(Id)'
    
    def generateColumnSnippet(columnName: str, goType: str):
        return columnName + ' ' + goToSqlTypeConversions[goType]

    createTableStatement = 'CREATE TABLE IF NOT EXISTS ' + tableName + '(Id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT'
    
    columnSnippets = []
    constraintSnippets = []

    for attribute in list(typeMeta['attributes'].keys()):
        if (attribute != 'Id'):
            #Id is already added at the front as a special case
            columnSnippets.append(generateColumnSnippet(attribute, typeMeta['attributes'][attribute]['type']))

    for relationship in list(typeMeta['relationships']['manyToOne'].keys()):
        columnSnippets.append(generateColumnSnippet(relationship, typeMeta['relationships']['manyToOne'][relationship]['type']))
        constraintSnippets.append(generateForeignKeyConstraintSnippet(relationship, typeMeta['relationships']['manyToOne'][relationship]['correspondingTable']))

    for snippet in columnSnippets:
        createTableStatement = createTableStatement + ', ' + snippet

    for snippet in constraintSnippets:
        createTableStatement = createTableStatement + ', ' + snippet

    return createTableStatement + ');'


def produceTestInsertStatements(tableName: str, typeMeta: dict):
    
    def getTestTypeDefault(columnName: str, goType: str, numberSeed: int):
        testTypeDefaults = {
            'TEXT': "'" + columnName + ' ' + str(numberSeed) + "'",
            #Number will end up corresponding to booleans (0/1), so we can safely assign this way for test purposes
            'NUMBER': 1,
            'REAL': float(numberSeed),
        }

        return str(testTypeDefaults[goToSqlTypeConversions[goType]])


    def generateInsertStatement(insertSeed: int):
        baseInsertStatement = 'INSERT INTO  ' + tableName + '(' 

        columnOrder = list(typeMeta['attributes'].keys())
        columnOrder.remove("Id")

        relationships = list(typeMeta['relationships'].keys())

        for column in columnOrder:
            baseInsertStatement += column + (', ' if column != columnOrder[-1] else '')

        for relationship in relationships:
            baseInsertStatement += ', ' + relationship
        
        baseInsertStatement += ') VALUES('

        for column in columnOrder:
                baseInsertStatement += getTestTypeDefault(column, typeMeta['attributes'][column]['type'], insertSeed) + (', ' if column != columnOrder[-1] else '')

        for relationship in relationships:
                baseInsertStatement += ', 1'

        baseInsertStatement += ');'

        return baseInsertStatement
    

    return [generateInsertStatement(i) for i in range(3)]

#Currently assuming full levels of relationship includes
def produceDTOForType(tableName: str, typeMeta: dict):

    dbArgName = 'db'
    objectArgName = tableName[0].lower() + tableName[1:]

    def produceConvertToTableTypeMethod(tableName: str, typeMeta: dict):
        lines = [
            'func ' + tableName + 'DTOTo' + tableName + '(' + objectArgName + ' *' + tableName + 'DTO) types.' + tableName + ' {',
            *indentLineBlock([
                'return types.' + tableName + '{',
                *indentLineBlock([
                    'Id: ' + objectArgName + '.Id,',
                    *[(attribute[0].upper() + attribute[1:] + ': ' + objectArgName + '.Attributes.' + attribute + ',' if attribute != 'Id' else '') for attribute in typeMeta['attributes']],
                    *[relationship[0].upper() + relationship[1:] + ': ' + objectArgName + '.Relationships.' + relationship + '.Id,' for relationship in typeMeta["relationships"]['manyToOne']],
                ]),
                '}',
            ]),
            '}'
        ]

        return lines
    

    def produceConvertToDTOMethod(tableName: str, typeMeta: dict):
        lines = [
            'func ' + tableName + 'To' + tableName + 'DTO(' + dbArgName + ' *gorm.DB, ' + objectArgName + ' *types.' + tableName + ') ' + tableName + 'DTO {',
            *indentLineBlock([
                *['var included' + relationship + ' types.' + typeMeta['relationships']['manyToOne'][relationship]["correspondingTable"] for relationship in typeMeta["relationships"]['manyToOne']],

                *['services.Get' + typeMeta['relationships']['manyToOne'][relationship]["correspondingTable"] + 'ById(' + dbArgName + ', int(*' + objectArgName + '.' + relationship + '), &included' + relationship + ')' for relationship in typeMeta["relationships"]['manyToOne']],

                'return ' + tableName + 'DTO{',
                *indentLineBlock([
                    'Id: ' + objectArgName + '.Id,',
                    'Attributes: ' + tableName + 'DTOAttributes{',
                    *indentLineBlock([(attribute[0].upper() + attribute[1:] + ': ' + objectArgName + '.' + attribute + ',' if attribute != 'Id' else '') for attribute in typeMeta['attributes']]),
                    '},',
                    'Relationships: ' + tableName + 'DTORelationships{',
                    *indentLineBlock([relationship[0].upper() + relationship[1:] + ': ' + typeMeta['relationships']['manyToOne'][relationship]["correspondingTable"] + 'To' + typeMeta['relationships']['manyToOne'][relationship]["correspondingTable"] + 'DTO(' + dbArgName + ', &included' + relationship + '),' for relationship in typeMeta["relationships"]['manyToOne']]),
                    '},',
                ]),
                '}',
            ]),
            '}'
        ]

        return lines

    lines = [
        *autogeneratedWarningMessage,
        '',
        'package generatedDTOs',
        '',
        'import (',
        *indentLineBlock([
            'types "AdventureEngineServer/generatedDatabaseTypes"',
            'services "AdventureEngineServer/generatedServices"' if len(typeMeta["relationships"]["manyToOne"]) > 0 else '',
  	        '"gorm.io/gorm"'
        ]),
        ')',
        '',
        'type ' + tableName + 'DTOAttributes struct {',
        *indentLineBlock([attribute[0].upper() + attribute[1:] + ' ' + typeMeta['attributes'][attribute]['type'] if attribute != 'Id' else '' for attribute in typeMeta['attributes']]),
        '}',
        '',
        'type ' + tableName + 'DTORelationships struct {',
        *indentLineBlock([relationship[0].upper() + relationship[1:] + ' ' + typeMeta['relationships']['manyToOne'][relationship]["correspondingTable"] + "DTO" for relationship in typeMeta['relationships']['manyToOne']]),
        '}',
        '',
        'type ' + tableName + 'DTO struct {',
        *indentLineBlock([
            'Id *float64',
            '',
            'Attributes ' + tableName + 'DTOAttributes',
            '',
            'Relationships ' + tableName + 'DTORelationships',
        ]),
        '}',
        '',
        *produceConvertToDTOMethod(tableName, typeMeta),
        '',
        *produceConvertToTableTypeMethod(tableName, typeMeta)
    ]

    return lines


def produceServiceFileForType(tableName: str, typeMeta: dict):

    dbArgName = 'db'
    objectArgName = tableName[0].lower() + tableName[1:]

    def produceServiceSaveMethod(tableName: str):
        lines = [
            'func Save' + tableName + '(' + dbArgName + ' *gorm.DB, ' + objectArgName + ' *types.' + tableName + ') error {',
            *indentLineBlock([
                'tx := ' + dbArgName + '.Begin()',
                '',
                'if tx.Error != nil {',
                    'return errors.New("Could not initialize transaction to save " + reflect.TypeOf(' + objectArgName + ').Name() + " entity")',
                '}',
                '',
                'defer func() {',
                *indentLineBlock([
                    'if r := recover(); r != nil {',
                    '   tx.Rollback()',    
                    '}'
                ]),
                '}()',
                '',
                'if err := tx.Error; err != nil {',
                '   return err',
                '}',
                '',
                'if err := tx.Save(' + objectArgName + ').Error; err != nil {',
                '   tx.Rollback()',
                '   return err',
                '}',
                '',
                'return tx.Commit().Error',
            ]),
            '}'
        ]

        return lines
    

    def produceServiceGetAllMethod(tableName: str):
    
        lines = [
            'func Get' + tableName + 's(' + dbArgName + ' *gorm.DB, ' + objectArgName  + 's *[]types.' + tableName + ') error {',
            *indentLineBlock([
	            'result := db.Table("' + tableName + '").Find(' + objectArgName + 's)',
                'return result.Error',  
            ]),
            '}'
        ]

        return lines


    def produceServiceGetByIdMethod(tableName: str):
    
        lines = [
            'func Get' + tableName + 'ById(' + dbArgName + ' *gorm.DB, id int, ' + objectArgName  + ' *types.' + tableName + ') error {',
            *indentLineBlock([
	            'result := db.Table("' + tableName + '").First(' + objectArgName + ', id)',
                'return result.Error',  
            ]),
            '}'
        ]

        return lines
    

    lines = [
        *autogeneratedWarningMessage,
        '',
        'package generatedServices',
        'import (',
        *indentLineBlock([
            '"errors"',
            '"reflect"',
            'types "AdventureEngineServer/generatedDatabaseTypes"',
  	        '"gorm.io/gorm"'
        ]),
        ')',
        '',
        *produceServiceGetAllMethod(tableName),
        '',
        *produceServiceGetByIdMethod(tableName),
        '',
        *produceServiceSaveMethod(tableName),
    ]

    return lines


def produceControllerFileForType(tableName: str):

    dbArgName = 'db'
    objectArgName = tableName[0].lower() + tableName[1:]

    def produceControllerGetMethod(tableName: str):
        
        contextArgName = 'ctx'
        objectArgName = tableName[0].lower() + tableName[1:]

        lines = [
            'func Get' + tableName + 's(' + contextArgName + ' *gin.Context, ' + dbArgName + ' *gorm.DB) {',
            *indentLineBlock([
                'var serviceBuffer []types.' + tableName,
                'err := services.Get' + tableName + 's(' + dbArgName + ', &serviceBuffer)',
                'if err != nil {',
                *indentLineBlock([
                    'ctx.IndentedJSON(http.StatusInternalServerError, err.Error())',
                    'return'
                ]),
                '}',
                '',
                'var returnBuffer []dtos.' + tableName + 'DTO',
                'for _, dbTypeInstance := range serviceBuffer {',
                *indentLineBlock([
                    'returnBuffer = append(returnBuffer, dtos.' + tableName + 'To' + tableName + 'DTO(' + dbArgName + ', &dbTypeInstance))'
                ]),
                '}',
                'ctx.IndentedJSON(http.StatusOK, returnBuffer)'
	        ]),
            '}'
        ]

        return lines
    
    def produceControllerGetByIdMethod(tableName: str):
        contextArgName = 'ctx'
        objectArgName = tableName[0].lower() + tableName[1:]

        lines = [
            'func Get' + tableName + 'ById(' + contextArgName + ' *gin.Context, ' + dbArgName + ' *gorm.DB) {',
            *indentLineBlock([
                'id := ctx.Param("id")',
                'idNum, err := strconv.Atoi(id)',
                'if err != nil {',
                *indentLineBlock([
                    contextArgName + '.IndentedJSON(http.StatusInternalServerError, err.Error())',
                    'return'
                ]),
                
                '}',
                'var serviceBuffer types.' + tableName,
                'err = services.Get' + tableName + 'ById(' + dbArgName + ', idNum, &serviceBuffer)',
                'if err != nil {',
                *indentLineBlock([
                    contextArgName + '.IndentedJSON(http.StatusInternalServerError, err.Error())',
                    'return'
                ]),
                '}',
                '',
                'returnBuffer := dtos.' + tableName + 'To' + tableName + 'DTO(' + dbArgName + ', &serviceBuffer)',
                'ctx.IndentedJSON(http.StatusOK, returnBuffer)'
	        ]),
            '}'
        ]

        return lines

    def produceControllerSaveMethod(tableName: str):
        contextArgName = 'ctx'
        objectArgName = tableName[0].lower() + tableName[1:]

        lines = [
            'func Save' + tableName + '(' + contextArgName + ' *gin.Context, ' + dbArgName + ' *gorm.DB) {',
            *indentLineBlock([
                'var serviceBuffer types.' + tableName,
                'err := services.Save' + tableName + '(' + dbArgName + ', &serviceBuffer)',
                'if err != nil {',
                *indentLineBlock([
                    'ctx.IndentedJSON(http.StatusInternalServerError, err.Error())',
                    'return'
                ]),
                '}',
                '',
                'returnBuffer := dtos.' + tableName + 'To' + tableName + 'DTO(' + dbArgName + ', &serviceBuffer)',
                'ctx.IndentedJSON(http.StatusOK, returnBuffer)'
	        ]),
            '}'
        ]

        return lines

    lines = [
        *autogeneratedWarningMessage,
        '',
        'package generatedControllers',
        'import (',
        *indentLineBlock([
  	        '"github.com/gin-gonic/gin"',
  	        '"gorm.io/gorm"',
            '"strconv"',
            '"net/http"',
            'services "AdventureEngineServer/generatedServices"',
            'types "AdventureEngineServer/generatedDatabaseTypes"',
            'dtos "AdventureEngineServer/generatedDTOs"'
        ]),
        ')',
        '',
        *produceControllerGetMethod(tableName),
        '',
        *produceControllerGetByIdMethod(tableName),
        '',
        *produceControllerSaveMethod(tableName)
    ]

    return lines


#This requires all tablenames instead of being applied 1 by 1 as it is generating the full file managing all generated table endpoints
def generateEndpointManager(tableNames: list[str]):
    ginContextName = 'router'
    dbContextName = 'db'

    def produceEndpointsForTable(tableName: str):
        lines = [
            'router.GET("/get' + tableName + 's", produceDBContextInjectedEndpoint(' + ginContextName + ', ' + dbContextName + ', controllers.Get' + tableName + 's))',
            'router.GET("/get' + tableName + '/:id", produceDBContextInjectedEndpoint(' + ginContextName + ', ' + dbContextName + ', controllers.Get' + tableName + 'ById))',
            'router.POST("/save' + tableName + '", produceDBContextInjectedEndpoint(' + ginContextName + ', ' + dbContextName + ', controllers.Save' + tableName + '))',
        ]

        return lines

    lines = [
        *autogeneratedWarningMessage,
        '',
        'package endpointManagers',
        'import (',
        *indentLineBlock([
  	        '"github.com/gin-gonic/gin"',
              '"gorm.io/gorm"',
            'controllers "AdventureEngineServer/generatedControllers"'
        ]),
        ')',
        '',
        'func produceDBContextInjectedEndpoint(' + ginContextName + ' *gin.Engine, ' + dbContextName + ' *gorm.DB, endpointHandler func(*gin.Context, *gorm.DB)) gin.HandlerFunc {',
        *indentLineBlock([
            'return func(ctx *gin.Context) {',
		    '   endpointHandler(ctx, ' + dbContextName + ')',
	        '}',
        ]),
        '}',
        '',
        'func ApplyGeneratedEndpoints(' + ginContextName + ' *gin.Engine, ' + dbContextName + ' *gorm.DB) {',
        #A little bit of code golf, as a treat (just unpacking the list of lists of generated lines since Python doesn't like embedding * syntax in here)
        *indentLineBlock([item for sublist in [produceEndpointsForTable(tableName) for tableName in tableNames] for item in sublist]),
        '}'
    ]

    return lines

if __name__ == '__main__': main()