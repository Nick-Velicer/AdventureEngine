import os
import re
import pprint
from utils.utils import produceDatabaseTargetType, produceParsedType, goToSqlTypeConversions

goTypeBaseDir = './goTypeBase'
dbTypeTargetDir = './generatedDatabaseTypes'
DTOTargetDir = './generatedDTOs'

autogeneratedWarningMessage = [
    '//*** CAUTION ***',
    '//This is an autogenerated file produced by regenerateBackend.py.',
    '//Edits made here will not persist after backend regeneration.',
]

#global context used for cross-service type reaching
typeMetas = {}

def indentLineBlock(lines: list):
    return ['   ' + line for line in lines]


def main():
    goTypeBaseDirectory = os.fsencode(goTypeBaseDir)

    dbTargetDir = os.path.dirname(dbTypeTargetDir)
    if not os.path.exists(dbTargetDir):
        os.makedirs(dbTargetDir)

    #Parsing types and adding results to the global context
    for file in os.listdir(goTypeBaseDirectory):
        fileName = os.fsdecode(file)

        if fileName.endswith('.go'): 
            tableName = fileName.replace('.go', '')

            try:
                typeMetas[tableName] = produceParsedType(goTypeBaseDir + '/' + fileName)
            except Exception as e:
                raise e

    print("Go types successfully parsed.")

    #Primary file generation for services, DTOs, SQL, and endpoint setup
    createStatements = []
    insertStatements = []
    tableNames = []

    for file in os.listdir(goTypeBaseDirectory):
        fileName = os.fsdecode(file)

        if fileName.endswith('.go'): 
            tableName = fileName.replace('.go', '')
            tableNames.append(tableName)
            typeMeta = typeMetas[tableName]

            try:
                typeMeta = produceParsedType(goTypeBaseDir + '/' + fileName)
                
            except Exception as e:
                raise e

            #Flattened database type generation
            dbTargetFileName = dbTypeTargetDir + "/" + fileName
            directory = os.path.dirname(dbTargetFileName)
            if not os.path.exists(directory):
                os.makedirs(directory)

            f = open(dbTargetFileName, "w")
            f.write(produceDatabaseTargetType(goTypeBaseDir + '/' + fileName, typeMetas[fileName.replace('.go', '')]))
            f.close()

            #Service generation
            serviceLines = produceServiceFileForType(tableName, typeMeta)
            serviceFilePath = 'generatedServices/' + tableName + 'Service.go'

            directory = os.path.dirname(serviceFilePath)
            if not os.path.exists(directory):
                os.makedirs(directory)

            f = open(serviceFilePath, 'w')
            f.writelines([i + '\n' for i in serviceLines])
            f.close()

            #DTO generation
            DTOLines = produceDTOForType(tableName, typeMeta)
            DTOFilePath = DTOTargetDir + '/' + tableName + "DTO.go"

            directory = os.path.dirname(DTOFilePath)
            if not os.path.exists(directory):
                os.makedirs(directory)

            f = open(DTOFilePath, 'w')
            f.writelines([i + '\n' for i in DTOLines])
            f.close()

            #Controller generation
            controllerLines = produceControllerFileForType(tableName)
            controllerFilePath = 'generatedControllers/' + tableName + 'Controller.go'
            directory = os.path.dirname(controllerFilePath)
            if not os.path.exists(directory):
                os.makedirs(directory)

            f = open(controllerFilePath, 'w')
            f.writelines([i + '\n' for i in controllerLines])
            f.close()

            #Auto-populated test db values generation
            createStatements.append(produceCreateTableStatement(tableName, typeMeta))
            insertStatements += produceTestInsertStatements(tableName, typeMeta)

            print("Generated backend dependencies for " + tableName + ".")
    
    
    f = open('endpointManagers/generatedEndpointManager.go', 'w')
    f.writelines([i + '\n' for i in generateEndpointManager(tableNames)])
    f.close()

    print("Successfully initialized API endpoints.")

    f = open('testCreates.sql', 'w')
    f.writelines([i + '\n' for i in createStatements])
    f.close()

    f = open('testInserts.sql', 'w')
    f.writelines([i + '\n' for i in insertStatements])
    f.close()

    print("Successfully initialized test SQL.")


#The following expect a dictionary in the return shape specified for produceParsedTypes
def produceCreateTableStatement(tableName: str, typeMeta: dict):
    
    def generateForeignKeyConstraintSnippet(columnName: str, targetTable: str):
        #The id name is currently locked as 'Id' from generation further up

        return 'CONSTRAINT fk_' + targetTable + ' FOREIGN KEY (' + columnName + ') REFERENCES ' + targetTable + '(Id)'
    
    def generateColumnSnippet(columnName: str, goType: str):
        return columnName + ' ' + goToSqlTypeConversions[goType]

    createTableStatement = 'CREATE TABLE IF NOT EXISTS ' + tableName + '(Id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT'
    
    columnSnippets = []
    constraintSnippets = []

    for attribute in list(typeMeta['attributes'].keys()):
        if (attribute != 'Id'):
            #Id is already added at the front as a special case
            columnSnippets.append(generateColumnSnippet(attribute, typeMeta['attributes'][attribute]['type']))

    for relationship in list(typeMeta['relationships']['manyToOne'].keys()):
        columnSnippets.append(generateColumnSnippet(relationship, typeMeta['relationships']['manyToOne'][relationship]['type']))
        constraintSnippets.append(generateForeignKeyConstraintSnippet(relationship, typeMeta['relationships']['manyToOne'][relationship]['correspondingTable']))

    for snippet in columnSnippets:
        createTableStatement = createTableStatement + ', ' + snippet

    for snippet in constraintSnippets:
        createTableStatement = createTableStatement + ', ' + snippet

    return createTableStatement + ');'


def produceTestInsertStatements(tableName: str, typeMeta: dict):
    
    def getTestTypeDefault(columnName: str, goType: str, numberSeed: int):
        testTypeDefaults = {
            'TEXT': "'" + columnName + ' ' + str(numberSeed) + "'",
            #Number will end up corresponding to booleans (0/1), so we can safely assign this way for test purposes
            'NUMBER': 1,
            'REAL': float(numberSeed),
        }

        return str(testTypeDefaults[goToSqlTypeConversions[goType]])


    def generateInsertStatement(insertSeed: int):
        baseInsertStatement = 'INSERT INTO  ' + tableName + '(' 

        columnOrder = list(typeMeta['attributes'].keys())
        columnOrder.remove("Id")

        relationships = list(typeMeta['relationships']['manyToOne'].keys())

        for column in columnOrder:
            baseInsertStatement += column + (', ' if column != columnOrder[-1] else '')

        for relationship in relationships:
            baseInsertStatement += ', ' + relationship
        
        baseInsertStatement += ') VALUES('

        for column in columnOrder:
                baseInsertStatement += getTestTypeDefault(column, typeMeta['attributes'][column]['type'], insertSeed) + (', ' if column != columnOrder[-1] else '')

        for relationship in relationships:
                baseInsertStatement += ', 1'

        baseInsertStatement += ');'

        return baseInsertStatement
    

    return [generateInsertStatement(i) for i in range(6)]

#Currently assuming full levels of relationship includes
def produceDTOForType(tableName: str, typeMeta: dict):
    contextArgName = 'context'
    objectArgName = tableName[0].lower() + tableName[1:]

    def produceConvertToTableTypeMethod(tableName: str, typeMeta: dict):
        lines = [
            'func ' + tableName + 'DTOTo' + tableName + '(' + objectArgName + ' *' + tableName + 'DTO) *types.' + tableName + ' {',
            *indentLineBlock([
                'var tableTypeBuffer types.' + tableName,
                '',
                'tableTypeBuffer.Id = ' + objectArgName + '.Id',
                *[('tableTypeBuffer.' + (attribute[0].upper() + attribute[1:] + ' = ' + objectArgName + '.Attributes.' + attribute + '') if attribute != 'Id' else '') for attribute in typeMeta['attributes']],
                '',
                *[
                    #Not technically using the indentLineBlock convention, but python doesn't like the extra inner looping/unpacking so this is relatively a reasonable tradeoff
                    'if (' + objectArgName + '.Relationships.ManyToOne.' + relationship + ' != nil) {\n' +
                    '      tableTypeBuffer.' + relationship + ' = ' + objectArgName + '.Relationships.ManyToOne.' + relationship + '.Id\n' + 
                    '   }\n'
                    for relationship in typeMeta["relationships"]['manyToOne']
                ],
                'return &tableTypeBuffer'
            ]),
            '}'
        ]

        return lines
    

    def produceConvertToDTOMethod(tableName: str, typeMeta: dict):
        lines = [
            'func ' + tableName + 'To' + tableName + 'DTO(' + contextArgName + ' *contextProviders.DTOContext, ' + objectArgName + ' *types.' + tableName + ') (*' + tableName + 'DTO, error) {',
            *indentLineBlock([
                'if ' + contextArgName + ' == nil {',
                *indentLineBlock([
                    'return nil, errors.New("No DTO context provided")',
                ]), 
                '}',
                '',
                'if (' + objectArgName + ' == nil) {',
                *indentLineBlock([
                    'return nil, errors.New("Cannot convert nil pointer passed to DTO conversion for table ' + tableName + '")'
                ]),
                '}',
                '',
                'if (slices.Contains(' + contextArgName + '.TraversedTables, reflect.TypeOf(*' + objectArgName + ').Name())) {',
                *indentLineBlock([
                    'fmt.Println("Hit circular catch case for table ' + tableName + '")',
                    'return nil, nil'
                ]),
                '}',
                '',
                'childDTOContext := contextProviders.DTOContext{',
                *indentLineBlock([
                    'DatabaseContext: ' + contextArgName + '.DatabaseContext,',
                    'TraversedTables: append(' + contextArgName + '.TraversedTables, reflect.TypeOf(*' + objectArgName + ').Name()),'
                ]),
                '}',
                ''
                'serviceContext := &contextProviders.ServiceContext{',
                *indentLineBlock([
                    'DatabaseContext: ' + contextArgName + '.DatabaseContext,',
                    'CurrentUser: nil,'
                ]),
                '}',
                '',
                *['var included' + relationship + ' *types.' + typeMeta['relationships']['manyToOne'][relationship]["correspondingTable"] for relationship in typeMeta["relationships"]['manyToOne']],
                *['var included' + relationship + 's []types.' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] for relationship in typeMeta["relationships"]['oneToMany']],
                '',
                *['var ' + relationship + 'DTO *' + typeMeta['relationships']['manyToOne'][relationship]["correspondingTable"] + "DTO" for relationship in typeMeta["relationships"]['manyToOne']],
                *['var ' + relationship + 'DTOs []*' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] + "DTO" for relationship in typeMeta["relationships"]['oneToMany']],
                '',
                'var err error',
                '',
                *[
                    #Not technically using the indentLineBlock convention, but python doesn't like the extra inner looping/unpacking so this is relatively a reasonable tradeoff
                    'if (' + objectArgName + '.' + relationship + ' != nil) {\n' +
                    '      included' + relationship + ', err = services.Get' + typeMeta['relationships']['manyToOne'][relationship]["correspondingTable"] + 'ById(serviceContext, contextProviders.ProduceGetByIdArgs[types.' + typeMeta['relationships']['manyToOne'][relationship]["correspondingTable"] + '](' + objectArgName + '.' + relationship + '))\n'  +
                    '      if err != nil {\n'  +
                    '         return nil, err\n' + 
                    '      }\n' +
                    '      ' + relationship + 'DTO, err = ' + typeMeta['relationships']['manyToOne'][relationship]["correspondingTable"] + 'To' + typeMeta['relationships']['manyToOne'][relationship]["correspondingTable"] + 'DTO(&childDTOContext, included' + relationship + ')\n'  +
                    '      if err != nil {\n'  +
                    '         return nil, err\n' + 
                    '      }\n' +
                    '   }\n'
                    for relationship in typeMeta["relationships"]['manyToOne']
                ],
                *[
                    'if (slices.Contains(' + contextArgName + '.TraversedTables, reflect.TypeOf(included' + relationship + 's).Elem().Name())) {\n' +
                    '      included' + relationship + 's = []types.' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] + '{}\n' +
                    '      fmt.Println("Hit circular catch case for table ' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] + '")\n' +
                    '   } else {\n' +
                    '      included' + relationship + 's, err = services.Get' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] + 's(serviceContext, contextProviders.ProduceGetArgs[types.' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] + ']("' + relationship + '", ' + tableName[0].lower() + tableName[1:] + '.Id))\n'  +
                    '      if err != nil {\n'  +
                    '         return nil, err\n' + 
                    '      }\n' +
                    '      ' + relationship + 'DTOs, err = utils.ErrorCompatibleMap(included' + relationship + 's, func(relationshipElement types.' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] + ') (*' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] + 'DTO, error) { return ' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] + 'To' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] + 'DTO(&childDTOContext, &relationshipElement) })\n'  +
                    '      if err != nil {\n'  +
                    '         return nil, err\n' + 
                    '      }\n' +
                    '   }\n'
                    for relationship in typeMeta["relationships"]['oneToMany']
                ],
                '',
                'return &' + tableName + 'DTO{',
                *indentLineBlock([
                    'Id: ' + objectArgName + '.Id,',
                    'Attributes: ' + tableName + 'DTOAttributes{',
                    *indentLineBlock([(attribute[0].upper() + attribute[1:] + ': nil,' if attribute == 'Password' else (attribute[0].upper() + attribute[1:] + ': ' + objectArgName + '.' + attribute + ',' if attribute != 'Id' else '')) for attribute in typeMeta['attributes']]),
                    '},',
                    'Relationships: ' + tableName + 'DTORelationships{',
                    *indentLineBlock([
                        'ManyToOne: ' + tableName + 'DTOManyToOneRelationships {',
                        *indentLineBlock([relationship + ': ' + relationship + 'DTO,' for relationship in typeMeta["relationships"]['manyToOne']]),
                        '},',
                        'OneToMany: ' + tableName + 'DTOOneToManyRelationships {',
                        *indentLineBlock([relationship + ': ' + relationship + 'DTOs,' for relationship in typeMeta["relationships"]['oneToMany']]),
                        '},',
                    ]),
                    '},',
                ]),
                '}, nil',
            ]),
            '}'
        ]

        return lines

    lines = [
        *autogeneratedWarningMessage,
        '',
        'package generatedDTOs',
        '',
        'import (',
        *indentLineBlock([
            'contextProviders "AdventureEngineServer/contextProviders"',
            'types "AdventureEngineServer/generatedDatabaseTypes"',
            'utils "AdventureEngineServer/utils"' if len(typeMeta["relationships"]["oneToMany"]) > 0 else '',
            'services "AdventureEngineServer/generatedServices"' if len(typeMeta["relationships"]["manyToOne"]) > 0 or len(typeMeta["relationships"]["oneToMany"]) > 0 else '',
            '"errors"',
            '"fmt"',
            '"reflect"',
            '"slices"',
        ]),
        ')',
        '',
        'type ' + tableName + 'DTOAttributes struct {',
        *indentLineBlock([attribute[0].upper() + attribute[1:] + ' ' + typeMeta['attributes'][attribute]['type'] if attribute != 'Id' else '' for attribute in typeMeta['attributes']]),
        '}',
        '',
        'type ' + tableName + 'DTOManyToOneRelationships struct {',
        *indentLineBlock([relationship + ' *' + typeMeta['relationships']['manyToOne'][relationship]["correspondingTable"] + "DTO" for relationship in typeMeta['relationships']['manyToOne']]),
        '}',
        '',
        'type ' + tableName + 'DTOOneToManyRelationships struct {',
        *indentLineBlock([relationship + ' []*' + typeMeta['relationships']['oneToMany'][relationship]["correspondingTable"] + "DTO" for relationship in typeMeta['relationships']['oneToMany']]),
        '}',
        '',
        'type ' + tableName + 'DTORelationships struct {',
        *indentLineBlock([
            'ManyToOne ' + tableName + 'DTOManyToOneRelationships',
            'OneToMany ' + tableName + 'DTOOneToManyRelationships',
        ]),
        '}',
        '',
        'type ' + tableName + 'DTO struct {',
        *indentLineBlock([
            'Id *int',
            '',
            'Attributes ' + tableName + 'DTOAttributes',
            '',
            'Relationships ' + tableName + 'DTORelationships',
        ]),
        '}',
        '',
        *produceConvertToDTOMethod(tableName, typeMeta),
        '',
        *produceConvertToTableTypeMethod(tableName, typeMeta)
    ]

    return lines


def produceServiceFileForType(tableName: str, typeMeta: dict):

    contextArgName = 'context'
    argsArgName = 'args'

    def produceServiceSaveMethod(tableName: str):
        lines = [
            'func Save' + tableName + '(' + contextArgName + ' *contextProviders.ServiceContext, ' + argsArgName + ' *contextProviders.SaveArgs[types.' + tableName + ']' + ') (contextProviders.SaveReturn[types.' + tableName + '], error) {',
            *indentLineBlock([
                'if ' + contextArgName + ' == nil {',
                *indentLineBlock([
                    'return nil, errors.New("No service context provided")',
                ]), 
                '}',
                '',
                'if ' + argsArgName + ' == nil {',
                *indentLineBlock([
                    'return nil, errors.New("No service arguments provided")',
                ]), 
                '}',
                '',
                'tx := ' + contextArgName + '.DatabaseContext.Begin()',
                '',
                'if tx.Error != nil {',
                *indentLineBlock([
                    'return nil, errors.New("Could not initialize transaction to save " + reflect.TypeOf(' + argsArgName + '.Items).Name() + " entity")',
                ]), 
                '}',
                '',
                'defer func() {',
                *indentLineBlock([
                    'if r := recover(); r != nil {',
                    *indentLineBlock([
                        'tx.Rollback()'
                    ]),  
                    '}'
                ]),
                '}()',
                '',
                'if err := tx.Error; err != nil {',
                *indentLineBlock([
                    'return nil, err',
                ]),
                '}',
                '',
                'if err := tx.Table("' + tableName + '").Save(' + argsArgName + '.Items).Error; err != nil {',
                *indentLineBlock([
                    'tx.Rollback()',
                    'return nil, err',
                ]),
                '}',
                ''
                'if tx.Commit().Error != nil {',
                *indentLineBlock([
                    'return nil, tx.Commit().Error',
                ]),
                '}',
                '',
                'return ' + argsArgName + '.Items, nil',
            ]),
            '}'
        ]

        return lines
    

    def produceServiceGetAllMethod(tableName: str):
    
        lines = [
            'func Get' + tableName + 's(' + contextArgName + ' *contextProviders.ServiceContext, ' + argsArgName + ' *contextProviders.GetArgs[types.' + tableName + ']' + ') (contextProviders.GetReturn[types.' + tableName + '], error) {',
            *indentLineBlock([
                'if ' + contextArgName + ' == nil {',
                *indentLineBlock([
                    'return nil, errors.New("No service context provided")',
                ]), 
                '}',
                '',
                'if ' + argsArgName + ' == nil {',
                *indentLineBlock([
                    'return nil, errors.New("No service arguments provided")',
                ]), 
                '}',
                '',
                'var returnBuffer []types.' + tableName,
                '',
                'filteredContext, err := utils.FilterTableContext(' + contextArgName + '.DatabaseContext.Table("' + tableName + '"), ' + argsArgName + '.Filters)',
                '',
                'if err != nil {',
                *indentLineBlock([
                    'return nil, err',
                ]),
                '}',
	            'result := filteredContext.Find(returnBuffer)',
                '',
                'if result.Error != nil {',
                *indentLineBlock([
                    'return nil, result.Error',
                ]),
                '}',
                '',
                'return returnBuffer, nil',  
            ]),
            '}'
        ]

        return lines


    def produceServiceGetByIdMethod(tableName: str):
    
        lines = [
            'func Get' + tableName + 'ById(' + contextArgName + ' *contextProviders.ServiceContext, ' + argsArgName + ' *contextProviders.GetByIdArgs[types.' + tableName + ']' + ') (contextProviders.GetByIdReturn[types.' + tableName + '], error) {',
            *indentLineBlock([
                'if ' + contextArgName + ' == nil {',
                *indentLineBlock([
                    'return nil, errors.New("No service context provided")',
                ]), 
                '}',
                '',
                'if ' + argsArgName + ' == nil {',
                *indentLineBlock([
                    'return nil, errors.New("No service arguments provided")',
                ]), 
                '}',
                '',
                'var returnPtr *types.' + tableName,
	            'result := ' + contextArgName + '.DatabaseContext.Table("' + tableName + '").First(returnPtr, ' + argsArgName + '.Id)',
                'if result.Error != nil {',
                *indentLineBlock([
                    'return nil, result.Error',
                ]),
                '}',
                '',
                'return returnPtr, nil',    
            ]),
            '}'
        ]

        return lines
    

    lines = [
        *autogeneratedWarningMessage,
        '',
        'package generatedServices',
        'import (',
        *indentLineBlock([
            '"errors"',
            '"reflect"',
            'contextProviders "AdventureEngineServer/contextProviders"',
            'types "AdventureEngineServer/generatedDatabaseTypes"',
            'utils "AdventureEngineServer/utils"'
        ]),
        ')',
        '',
        *produceServiceGetAllMethod(tableName),
        '',
        *produceServiceGetByIdMethod(tableName),
        '',
        *produceServiceSaveMethod(tableName),
    ]

    return lines


def produceControllerFileForType(tableName: str):

    dbArgName = 'db'
    objectArgName = tableName[0].lower() + tableName[1:]

    def produceControllerGetMethod(tableName: str):
        
        contextArgName = 'context'
        objectArgName = tableName[0].lower() + tableName[1:]

        lines = [
            'func Get' + tableName + 's(' + contextArgName + ' *contextProviders.GeneratedControllerContext[types.' + tableName + ', dtos.' + tableName + 'DTO, contextProviders.GetArgs[types.' + tableName + '], contextProviders.GetReturn[types.' + tableName + ']]) {',
            *indentLineBlock([
                'if ' + contextArgName + ' == nil {',
                *indentLineBlock([
                    'panic("No controller context provided")',
                ]), 
                '}',
                'queryParams := ' + contextArgName + '.RequestContext.Request.URL.Query()',
                '',
                '//Since we can have multiple filters, that sometimes doesn\'t play nicely with',
                '//Gin\'s parameter pulling, so they need to be isolated manually.',
                're := regexp.MustCompile(`filter\\[`)',
                'filterParams := make(map[string]string)',
                'for key, value := range queryParams {',
                *indentLineBlock([
                    'if re.MatchString(key) && len(value) == 1 {',
                    *indentLineBlock([
                        'filterParams[key] = value[0]'
                    ]),
                    '} else {',
                    *indentLineBlock([
                        'fmt.Println("Unexpected filter configuration for " + key + ", skipping:")',
                        'fmt.Println(value)'
                    ]),
                    '}'
                ]),
                '}',
                '',
                'parsedFilters := utils.ParseFilterURLExpression(filterParams)',
                '',
                'serviceBuffer, err := ' + contextArgName + '.ServiceAction(&contextProviders.GetArgs[types.' + tableName + ']{ Filters: &parsedFilters })',
                'if err != nil {',
                *indentLineBlock([
                    '' + contextArgName + '.RequestContext.IndentedJSON(http.StatusInternalServerError, err.Error())',
                    'return'
                ]),
                '}',
                '',
                'var returnBuffer []dtos.' + tableName + 'DTO',
                'for _, dbTypeInstance := range serviceBuffer {',
                *indentLineBlock([
                    'pointerToDTO, err := ' + contextArgName + '.DTOConverter(&dbTypeInstance)',
                    'if (err != nil) {',
                    *indentLineBlock([
                        '' + contextArgName + '.RequestContext.IndentedJSON(http.StatusInternalServerError, err.Error())',
                        'return'
                    ]),
                    '}',
                    '',
                    'if (pointerToDTO == nil) {',
                    *indentLineBlock([
                        '' + contextArgName + '.RequestContext.IndentedJSON(http.StatusInternalServerError, errors.New("DTO conversion resulted in nil for object of type ' + tableName + '"))',
                        'return'
                    ]),
                    '}',
                    '',
                    'returnBuffer = append(returnBuffer, *pointerToDTO)'
                ]),
                '}',
                '' + contextArgName + '.RequestContext.IndentedJSON(http.StatusOK, returnBuffer)'
	        ]),
            '}'
        ]

        return lines
    
    def produceControllerGetByIdMethod(tableName: str):
        contextArgName = 'context'
        objectArgName = tableName[0].lower() + tableName[1:]

        lines = [
            'func Get' + tableName + 'ById(' + contextArgName + ' *contextProviders.GeneratedControllerContext[types.' + tableName + ', dtos.' + tableName + 'DTO, contextProviders.GetByIdArgs[types.' + tableName + '], contextProviders.GetByIdReturn[types.' + tableName + ']]) {',
            *indentLineBlock([
                'if ' + contextArgName + ' == nil {',
                *indentLineBlock([
                    'panic("No controller context provided")',
                ]), 
                '}',
                '',
                'id := ' + contextArgName + '.RequestContext.Param("id")',
                'idNum, err := strconv.Atoi(id)',
                'if err != nil {',
                *indentLineBlock([
                    contextArgName + '.RequestContext.IndentedJSON(http.StatusInternalServerError, err.Error())',
                    'return'
                ]),
                
                '}',
                'serviceBuffer, err := ' + contextArgName + '.ServiceAction(&contextProviders.GetByIdArgs[types.' + tableName + ']{ Id: idNum })',
                'if err != nil {',
                *indentLineBlock([
                    contextArgName + '.RequestContext.IndentedJSON(http.StatusInternalServerError, err.Error())',
                    'return'
                ]),
                '}',
                '',
                'if serviceBuffer == nil {',
                *indentLineBlock([
                    contextArgName + '.RequestContext.IndentedJSON(http.StatusOK, nil)',
                    'return'
                ]),
                '}',
                '',
                'returnBuffer, err := ' + contextArgName + '.DTOConverter(serviceBuffer)',
                '',
                'if err != nil {',
                *indentLineBlock([
                    contextArgName + '.RequestContext.IndentedJSON(http.StatusInternalServerError, err.Error())',
                    'return'
                ]),
                '}',
                '',
                'if (returnBuffer == nil) {',
                    *indentLineBlock([
                        '' + contextArgName + '.RequestContext.IndentedJSON(http.StatusInternalServerError, errors.New("DTO conversion resulted in nil for object of type ' + tableName + '"))',
                        'return'
                    ]),
                '}',
                '' + contextArgName + '.RequestContext.IndentedJSON(http.StatusOK, returnBuffer)'
	        ]),
            '}'
        ]

        return lines

    def produceControllerSaveMethod(tableName: str):
        contextArgName = 'context'
        objectArgName = tableName[0].lower() + tableName[1:]

        lines = [
            'func Save' + tableName + '(' + contextArgName + ' *contextProviders.GeneratedControllerContext[types.' + tableName + ', dtos.' + tableName + 'DTO, contextProviders.SaveArgs[types.' + tableName + '], contextProviders.SaveReturn[types.' + tableName + ']]) {',
            *indentLineBlock([
                'if ' + contextArgName + ' == nil {',
                *indentLineBlock([
                    'panic("No controller context provided")',
                ]), 
                '}',
                '',
                '//Weirdness with unmarshalling, cannot unmarshal into a nil pointer, there must be some pre-initialization somewhere along the line',
                'var DTOBuffer *dtos.' + tableName + 'DTO = &dtos.' + tableName + 'DTO{}',
                'var batchDTOBuffer []*dtos.' + tableName + 'DTO',
                'var serviceBuffer []*types.' + tableName,
                '',
                '//If neither a single item nor a collection can be bound to JSON, fail early',
                '//ShouldBindBodyWith is used instead of ShouldBindJSON since the latter prevents multiple bind attempts',
                'if err := ' + contextArgName + '.RequestContext.ShouldBindBodyWith(DTOBuffer, binding.JSON); err == nil {',
                *indentLineBlock([
                    '',
                    'serviceBuffer = []*types.' + tableName + '{' + contextArgName + '.DTOFlattener(DTOBuffer)}',

                    'serviceReturn, err := ' + contextArgName + '.ServiceAction(&contextProviders.SaveArgs[types.' + tableName + ']{ Items: serviceBuffer })',
                    'if err != nil {',
                    *indentLineBlock([
                        '' + contextArgName + '.RequestContext.IndentedJSON(http.StatusInternalServerError, err.Error())',
                        'return'
                    ]),
                    '}',
                    '',
                    'returnBuffer, err := ' + contextArgName + '.DTOConverter(serviceReturn[0])',
                    'if err != nil {',
                    *indentLineBlock([
                        '' + contextArgName + '.RequestContext.IndentedJSON(http.StatusInternalServerError, err.Error())',
                        'return'
                    ]),
                    '}',
                    '',
                    'if (returnBuffer == nil) {',
                    *indentLineBlock([
                        '' + contextArgName + '.RequestContext.IndentedJSON(http.StatusInternalServerError, errors.New("DTO conversion resulted in nil for object of type ' + tableName + '"))',
                        'return'
                    ]),
                    '}',
                    '',
                    '' + contextArgName + '.RequestContext.IndentedJSON(http.StatusOK, returnBuffer)',
                    'return',
                    ''
                ]),
                '} else if err := ' + contextArgName + '.RequestContext.ShouldBindBodyWith(&batchDTOBuffer, binding.JSON); err == nil {',
                *indentLineBlock([
                    '',
                    'serviceBuffer = utils.Map(batchDTOBuffer, func(dto *dtos.' + tableName + 'DTO) *types.' + tableName + ' { return ' + contextArgName + '.DTOFlattener(dto) })',
                    'serviceReturn, err := ' + contextArgName + '.ServiceAction(&contextProviders.SaveArgs[types.' + tableName + ']{ Items: serviceBuffer })',
                    'if err != nil {',
                    *indentLineBlock([
                        '' + contextArgName + '.RequestContext.IndentedJSON(http.StatusInternalServerError, err.Error())',
                        'return'
                    ]),
                    '}',
                    '',
                    'returnBuffer, err := utils.ErrorCompatibleMap(serviceReturn, func(dbReturn *types.' + tableName + ') (*dtos.' + tableName + 'DTO, error) { return ' + contextArgName + '.DTOConverter(dbReturn) })',
                    '',
                    'if err != nil {',
                    *indentLineBlock([
                        '' + contextArgName + '.RequestContext.IndentedJSON(http.StatusInternalServerError, err.Error())',
                        'return'
                    ]),
                    '}',
                    '',
                    '' + contextArgName + '.RequestContext.IndentedJSON(http.StatusOK, returnBuffer)',
                    'return',
                    ''
                ]),
                '} else {',
                *indentLineBlock([
                    '' + contextArgName + '.RequestContext.IndentedJSON(http.StatusBadRequest, err.Error())',
                    'return'
                ]),
                '}',
	        ]),
            '}'
        ]

        return lines

    lines = [
        *autogeneratedWarningMessage,
        '',
        'package generatedControllers',
        'import (',
        *indentLineBlock([
            '"errors"',
            '"fmt"',
            '"github.com/gin-gonic/gin/binding"',
            '"net/http"',
            '"regexp"',
            '"strconv"',
            'contextProviders "AdventureEngineServer/contextProviders"',
            'types "AdventureEngineServer/generatedDatabaseTypes"',
            'dtos "AdventureEngineServer/generatedDTOs"',
            'utils "AdventureEngineServer/utils"',
        ]),
        ')',
        '',
        *produceControllerGetMethod(tableName),
        '',
        *produceControllerGetByIdMethod(tableName),
        '',
        *produceControllerSaveMethod(tableName)
    ]

    return lines


#This requires all tablenames instead of being applied 1 by 1 as it is generating the full file managing all generated table endpoints
def generateEndpointManager(tableNames: list[str]):

    #Preventing the user endpoints from being exposed, the CRUD workflow for those will be handled by custom endpoints
    tableNames.remove("User")

    ginContextName = 'router'
    dbContextName = 'db'

    def produceEndpointsForTable(tableName: str):
        lines = [
            'router.GET("/get' + tableName + 's", contextProviders.ProduceContextInjectedGetController(' + dbContextName + ', services.Get' + tableName + 's, dtos.' + tableName + 'To' + tableName + 'DTO, dtos.' + tableName + 'DTOTo' + tableName + ', controllers.Get' + tableName + 's))',
            'router.GET("/get' + tableName + '/:id", contextProviders.ProduceContextInjectedGetByIdController(' + dbContextName + ', services.Get' + tableName + 'ById, dtos.' + tableName + 'To' + tableName + 'DTO, dtos.' + tableName + 'DTOTo' + tableName + ', controllers.Get' + tableName + 'ById))',
            'router.POST("/save' + tableName + '", contextProviders.ProduceContextInjectedSaveController(' + dbContextName + ', services.Save' + tableName + ', dtos.' + tableName + 'To' + tableName + 'DTO, dtos.' + tableName + 'DTOTo' + tableName + ', controllers.Save' + tableName + '))',
        ]

        return lines

    lines = [
        *autogeneratedWarningMessage,
        '',
        'package endpointManagers',
        'import (',
        *indentLineBlock([
  	        '"github.com/gin-gonic/gin"',
            '"gorm.io/gorm"',
            'controllers "AdventureEngineServer/generatedControllers"',
            'contextProviders "AdventureEngineServer/contextProviders"',
            'dtos "AdventureEngineServer/generatedDTOs"',
            'services "AdventureEngineServer/generatedServices"'
        ]),
        ')',
        '',
        'func ApplyGeneratedEndpoints(' + ginContextName + ' *gin.Engine, ' + dbContextName + ' *gorm.DB) {',
        #A little bit of code golf, as a treat (just unpacking the list of lists of generated lines since Python doesn't like embedding * syntax in here)
        *indentLineBlock([item for sublist in [produceEndpointsForTable(tableName) for tableName in tableNames] for item in sublist]),
        '}'
    ]

    return lines

if __name__ == '__main__': main()