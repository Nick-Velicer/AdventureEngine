import os
import pandas as pd
import re
import pprint
from utils.utils import produceDatabaseTargetType, produceParsedType, goToSqlTypeConversions

autogeneratedWarningMessage = [
    '--*** CAUTION ***',
    '--This is an autogenerated file produced by regenerateMigrations.py.',
    '--Edits made here will not persist after migration regeneration.',
]

goTypeBaseDir = './goTypeBase'
migrationsBaseDir = './generatedMigrations'



#global type meta context
typeMetas = {}

#global contexts to be able to link generated migrations to other generated tables
dice = []
baseStats = []
spellSchools = []
spells = []
classes = []

#This will be applied to the beginning of migrations to preserve the dependent order for foreign keys
migrationOrderNumber = 1


def main():
    #Since this is a development time tool, we can get away with depending on some of the
    #output from regenerateBackend.py, since it'd be a pain to have this go through the same
    #generation steps just to have this be runnable in a more standalone fashion.
    goTypeBaseDirectory = os.fsencode(goTypeBaseDir)

    #Parsing types and adding results to the global context
    for file in os.listdir(goTypeBaseDirectory):
        fileName = os.fsdecode(file)

        if fileName.endswith('.go'): 
            tableName = fileName.replace('.go', '')

            try:
                typeMetas[tableName] = produceParsedType(goTypeBaseDir + '/' + fileName)
            except Exception as e:
                raise e

    print("Types successfully parsed.")

    if not os.path.exists(migrationsBaseDir):
        os.makedirs(migrationsBaseDir)

    #Migrations are created in order of foreign key dependency, with later generations relying
    #on the state of previously generated tables to link (providing better fk safety)

    regenerateDiceMigration()

    regenerateBasicStatMigration()

    regenerateDomainClassMigration()

    regenerateSavingThrowsMigration()

    regenerateSpellSchoolsMigration()

    regenerateSpellsAndClassSpellsMigrations()

    print("Finished regenerating migrations.")

#region Migration Utilities

def produceInsertStatementsForObjects(tableName: str, typeMeta: dict, objects: list):
    #expecting that objects is a list of flattened datatable types

    if (len(objects) < 1):
        return []

    def generateInsertStatement(obj: dict):
        baseInsertStatement = 'INSERT INTO ' + tableName + '(\n\t' 

        columnOrder = list(obj.keys())

        baseInsertStatement += "".join([column + (',\n\t' if index != len(columnOrder)-1 else '\n') for index, column in enumerate(columnOrder)])
        
        baseInsertStatement += ') VALUES(\n\t'

        valuesBuffer = {}

        for column in columnOrder:
            strTranslatedValue = ""

            if (obj[column] == None):
                strTranslatedValue = "NULL"

            elif (type(obj[column]) == str):
                strTranslatedValue = "'" + obj[column].replace("'", "''") + "'"

            elif (type(obj[column]) == int):
                strTranslatedValue = str(obj[column])
            
            else:
                strTranslatedValue = "NULL"
            
            valuesBuffer[column] = (strTranslatedValue)

        values = list(valuesBuffer.values())

        baseInsertStatement += "".join([value + (",\n\t" if index != len(values)-1 else "\n") for index, value in enumerate(values)]) + ")"

        baseInsertStatement += "\nON CONFLICT (Id) DO UPDATE SET\n\t" + "".join([(key + " = " + valuesBuffer[key] + (",\n\t" if index != len(columnOrder)-2 else "\n;\n")) if key != "IsActive" else "" for index, key in enumerate(columnOrder)])

        return baseInsertStatement
    

    return [generateInsertStatement(obj) for obj in objects]


def writeInsertLines(fileName: str, lines: list):
    f = open(fileName, 'w')
    f.writelines([i + '\n' for i in lines])
    f.close()


def produceMigrationFileFromObjects(tableName: str, objects: list):
    #We do not reference the objects from the global instance for this even though that 
    #is available for use for fk-dependent migrations, since not all migrations will end up 
    #writing to a global context.

    global migrationOrderNumber

    #Generating ids for each item, this will overwrite any passed in id
    objects = [{**obj, **{
        "Id": (index + 1),
        "IsActive": 1
    }} for index, obj in enumerate(objects)]

    lines = produceInsertStatementsForObjects(tableName, typeMetas[tableName], objects)
    writeInsertLines(migrationsBaseDir + '/' + str(migrationOrderNumber) + '__' + tableName + '.sql', lines)
    print(tableName + " migration successfully generated.")

    migrationOrderNumber += 1

    #There's some funkiness with adjusting a dynamic global list reference that's passed in as a param,
    #so we'll just return this back for the migration to update it with the explicit global reference
    return objects


def getForeignKeyIdForTitle(tableObjects: list, title: str):
    return next((x["Id"] for x in tableObjects if x["Title"] == title), None)

#endregion

#region Migration Producers

def regenerateDiceMigration():

    standardFaceCounts = [4, 6, 8, 10, 12, 20, 100]

    global dice

    dice = [
        {
            "Title": "d" + str(faceCount),
            "Minimum": 1,
            "Maximum": faceCount,
            "Description": "A " + str(faceCount) + "-sided dice"
        } for faceCount in standardFaceCounts]

    dice = produceMigrationFileFromObjects("DomainDice", dice)
   

def regenerateBasicStatMigration():
    baseStatNames = ["Strength", "Dexterity", "Constitution", "Intelligence", "Wisdom", "Charisma"]

    global baseStats

    baseStats = [
        {
            "Title": title,
            "IsBaseStat": 1,
            "Abbreviation": title[:3].upper(),
        } for title in baseStatNames]

    baseStats = produceMigrationFileFromObjects("DomainCharacterStat", baseStats)


def regenerateDomainClassMigration():
    
    global dice
    global classes
    global baseStats

    #Directly assigning values here since there's not really a convenient way to generate/map from a simpler collection for this
    classes = [
        {
            "Title": "Barbarian",
            "Description": "Barbarians are mighty warriors who are powered by primal forces of the multiverse that manifest as a Rage.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d12"),
        },
        {
            "Title": "Bard",
            "Description": "Bards are expert at inspiring others, soothing hurts, disheartening foes, and creating illusions.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d8"),
            "SpellcastingStat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Charisma")
        },
        {
            "Title": "Cleric",
            "Description": "Clerics can reach out to the divine magic of the Outer Planes and channel it to bolster people and battle foes.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d8"),
            "SpellcastingStat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Wisdom")
        },
        {
            "Title": "Druid",
            "Description": "Druids call on the forces of nature, harnessing magic to heal, transform into animals, and wield elemental destruction.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d8"),
            "SpellcastingStat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Wisdom")
        },
        {
            "Title": "Fighter",
            "Description": "Fighters all share an unparalleled prowess with weapons and armor, and are well acquainted with death, both meting it out and defying it.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d10"),
        },
        {
            "Title": "Monk",
            "Description": "Monks focus their internal reservoirs of power to create extraordinary, even supernatural, effects.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d8"),
        },
        {
            "Title": "Paladin",
            "Description": "Paladins live on the front lines of the cosmic struggle, united by their oaths against the forces of annihilation.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d10"),
            "SpellcastingStat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Charisma")
        },
        {
            "Title": "Ranger",
            "Description": "Rangers are honed with deadly focus and harness primal powers to protect the world from the ravages of monsters and tyrants.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d10"),
            "SpellcastingStat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Wisdom")
        },
        {
            "Title": "Rogue",
            "Description": "Rogues have a knack for finding the solution to just about any problem, prioritizing subtle strikes over brute strength.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d8"),
            "SpellcastingStat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Wisdom")
        },
        {
            "Title": "Sorcerer",
            "Description": "Sorcerers harness and channel the raw, roiling power of innate magic that is stamped into their very being.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d6"),
            "SpellcastingStat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Charisma")
        },
        {
            "Title": "Warlock",
            "Description": "Warlocks quest for knowledge that lies hidden in the fabric of the multiverse, piecing together arcane secrets to bolster their own power.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d8"),
            "SpellcastingStat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Charisma")
        },
        {
            "Title": "Wizard",
            "Description": "Wizards cast spells of explosive fire, arcing lightning, subtle deception, and spectacular transformations.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d6"),
            "SpellcastingStat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Intelligence")
        },
        {
            "Title": "Artificer",
            "Description": "Masters of invention, artificers use ingenuity and magic to unlock extraordinary capabilities in objects.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d8"),
            "SpellcastingStat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Intelligence")
        },
    ]

    classes = produceMigrationFileFromObjects("DomainClass", classes)


def regenerateSavingThrowsMigration():

    global classes
    global baseStats

    savingThrows = [
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Barbarian"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Strength"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Barbarian"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Constitution"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Bard"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Dexterity"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Bard"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Charisma"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Cleric"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Wisdom"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Cleric"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Charisma"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Druid"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Intelligence"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Druid"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Wisdom"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Fighter"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Strength"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Fighter"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Constitution"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Monk"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Strength"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Monk"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Dexterity"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Paladin"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Wisdom"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Paladin"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Charisma"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Ranger"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Strength"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Ranger"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Dexterity"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Rogue"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Dexterity"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Rogue"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Intelligence"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Sorcerer"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Constitution"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Sorcerer"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Charisma"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Warlock"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Wisdom"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Warlock"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Charisma"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Wizard"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Intelligence"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Warlock"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Wisdom"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Artificer"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Constitution"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Artificer"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Intelligence"),
        },
    ]

    savingThrows = produceMigrationFileFromObjects("ClassSave", savingThrows)
    

def regenerateSpellSchoolsMigration():

    global spellSchools

    spellSchools = [
        {
            "Title": "Abjuration",
        },
        {
            "Title": "Conjuration",
        },
        {
            "Title": "Divination",
        },
        {
            "Title": "Enchantment",
        },
        {
            "Title": "Evocation",
        },
        {
            "Title": "Illusion",
        },
        {
            "Title": "Necromancy",
        },
        {
            "Title": "Transmutation",
        },
    ]

    spellSchools = produceMigrationFileFromObjects("DomainSpellSchool", spellSchools)


def regenerateSpellsAndClassSpellsMigrations():

    global spellSchools
    global spells
    global classes

    #This will be populated separately with the generated list of spells classes have access to
    #for use in a separate generation step
    classSpellMappings = {}

    #region Non-Lambda Helpers

    def discernCastingTime(obj: dict, value: str):
        if "bonus" in value:
            return {**obj, **{"IsBonusAction": 1}}
        
        if "action" in value:
            return {**obj, **{"IsAction": 1}}
        
        if "minute" in value:
            return {**obj, **{"MinuteCastTime": int(re.sub("[^0-9]", "", value.split(" minute")[0]))}}

        if "hour" in value:
            return {**obj, **{"HourCastTime": int(re.sub("[^0-9]", "", value.split(" hour")[0]))}}
        
        return obj

    def discernDuration(obj: dict, value: str):
        if "Instantaneous" in value:
            return {**obj, **{"IsInstantaneous": 1}}
        
        if "round" in value:
            return {**obj, **{"RoundDuration": int(re.sub("[^0-9]", "", value.split(" round")[0]))}}
        
        if "minute" in value:
            return {**obj, **{"MinuteDuration": int(re.sub("[^0-9]", "", value.split(" minute")[0]))}}

        if "hour" in value:
            return {**obj, **{"HourDuration": int(re.sub("[^0-9]", "", value.split(" hour")[0]))}}
        
        if "day" in value:
            return {**obj, **{"DayDuration": int(re.sub("[^0-9]", "", value.split(" day")[0]))}}

        if "dispelled" in value:
            return {**obj, **{"LastsUntilDispelled": 1}}
        
        return obj

    def discernRange(obj: dict, value: str):
        if "Touch" in value:
            return {**obj, **{"RequiresTouch": 1}}
        
        if "Self" in value:
            return {**obj, **{"TargetsSelf": 1}}

        if "feet" in value:
            return {**obj, **{"RangeFeet": int(value.split(" feet")[0])}}

        if "mile" in value:
            return {**obj, **{"RangeMiles": int(value.split(" mile")[0])}}
        
        return obj

    def addClassSpellMapping(obj: dict, value: str):
        #Since this is a relationship for another table, update a separate list to work with
        #outside of the spell context while still being called through the same interface

        accessingClasses = value.split(",")

        for domainClass in accessingClasses:
            if (domainClass not in classSpellMappings):
                classSpellMappings[domainClass] = [obj["Title"]]
            else:
                classSpellMappings[domainClass].append(obj["Title"])

        return obj

    #endregion

    fieldTranslations = {
        "name": lambda obj, value: {**obj, **{"Title": value}},
        "level": lambda obj, value: {**obj, **{"LevelRequirement": int(value)}},
        "school": lambda obj, value: {**obj, **{"School__DomainSpellSchool": getForeignKeyIdForTitle(spellSchools, value)}},
        "V": lambda obj, value: {**obj, **{"HasVerbalRequirement": 0 if value == False else 1}},
        "S": lambda obj, value: {**obj, **{"HasSomaticRequirement": 0 if value == False else 1}},
        "M": lambda obj, value: {**obj, **{"MaterialComponent": None if str(value) == "nan" else str(value)}},
        "casting_time": discernCastingTime,
        "concentration": lambda obj, value: {**obj, **{"ConcentrationRequired": 0 if value == False else 1}},
        "duration": discernDuration,
        "range": discernRange,
        "ritual": lambda obj, value: {**obj, **{"IsRitual": 0 if value == False else 1}},
        "description": lambda obj, value: {**obj, **{"Description": value}},
        #ignoring higher level effect for now since that'll take some finagling
        "cast_higher": lambda obj, value: obj,
        "higher_levels": lambda obj, value: obj,
        "classes": addClassSpellMapping
    }

    #From https://github.com/TheDataRogue/dnd-5e-spells
    df = pd.read_excel("resources/D&D 5E Spells.xlsx")
    df = df.sort_values('name').reset_index().drop('index',axis=1)

    #This uploads to a global spell buffer, which will recieve generated ids for the 
    #class-spell mapping table migration to access within this same context (both are
    #sourced from the .xlsx file, so it makes sense to just keep the context within here)
    for index, row in df.iterrows():
        spellObjectBuffer = {}

        for field in fieldTranslations.keys():
            spellObjectBuffer = fieldTranslations[field](spellObjectBuffer, row[field])
        
        spells.append(spellObjectBuffer)
    
    spells = produceMigrationFileFromObjects("DomainSpell", spells)

    #Additionally generating the class-spell access context
    convertedClassSpellMappings = []

    for domainClass in classSpellMappings.keys():
        for spellTitle in classSpellMappings[domainClass]:
            convertedClassSpellMappings.append({
                "Class__DomainClass": getForeignKeyIdForTitle(classes, domainClass),
                "Spell__DomainSpell": getForeignKeyIdForTitle(spells, spellTitle)
            })

    produceMigrationFileFromObjects("ClassSpell", spellSchools)
    
#endregion


if __name__ == '__main__': main()