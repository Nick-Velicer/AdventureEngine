import os
import pandas as pd
import re
import pprint
from utils.utils import produceDatabaseTargetType, produceParsedType, goToSqlTypeConversions

autogeneratedWarningMessage = [
    '--*** CAUTION ***',
    '--This is an autogenerated file produced by regenerateMigrations.py.',
    '--Edits made here will not persist after migration regeneration.',
]

goTypeBaseDir = './goTypeBase'
migrationsBaseDir = './generatedMigrations'



#global type meta context
typeMetas = {}

#global contexts to be able to link generated migrations to other generated tables
dice = []
diceRollTypes = []
diceRollSubTypes = []
baseStats = []
actions = []
spellSchools = []
spells = []
classes = []
subClasses = []
conditions = []
classTraits = []
quantifiers = []

#This will be applied to the beginning of migrations to preserve the dependent order for foreign keys
migrationOrderNumber = 1


def main():
    #Since this is a development time tool, we can get away with depending on some of the
    #output from regenerateBackend.py, since it'd be a pain to have this go through the same
    #generation steps just to have this be runnable in a more standalone fashion.
    goTypeBaseDirectory = os.fsencode(goTypeBaseDir)

    #Parsing types and adding results to the global context
    for file in os.listdir(goTypeBaseDirectory):
        fileName = os.fsdecode(file)

        if fileName.endswith('.go'): 
            tableName = fileName.replace('.go', '')

            try:
                typeMetas[tableName] = produceParsedType(goTypeBaseDir + '/' + fileName)
            except Exception as e:
                raise e

    print("Types successfully parsed.")

    if not os.path.exists(migrationsBaseDir):
        os.makedirs(migrationsBaseDir)

    #Migrations are created in order of foreign key dependency, with later generations relying
    #on the state of previously generated tables to link (providing better fk safety)

    regenerateDiceMigration()

    regenerateDomainDiceRollTypeMigration()

    regenerateDomainDiceRollSubTypeMigration()

    regenerateBasicStatMigration()

    regenerateActionsMigration()

    regenerateDomainClassMigration()

    regenerateDomainSubClassMigration()

    regenerateDomainConditionsMigration()

    regenerateSavingThrowsMigration()

    regenerateSpellSchoolsMigration()

    regenerateSpellsAndClassSpellsMigrations()

    regenerateQuantifiersMigration()

    print("Finished regenerating migrations.")

#region Migration Utilities

def produceInsertStatementsForObjects(tableName: str, typeMeta: dict, objects: list):
    #expecting that objects is a list of flattened datatable types

    if (len(objects) < 1):
        return []

    def generateInsertStatement(obj: dict):
        baseInsertStatement = 'INSERT INTO ' + tableName + '(\n\t' 

        columnOrder = list(obj.keys())

        baseInsertStatement += "".join([column + (',\n\t' if index != len(columnOrder)-1 else '\n') for index, column in enumerate(columnOrder)])
        
        baseInsertStatement += ') VALUES(\n\t'

        valuesBuffer = {}

        for column in columnOrder:
            strTranslatedValue = ""

            if (obj[column] == None):
                strTranslatedValue = "NULL"

            elif (type(obj[column]) == str):
                strTranslatedValue = "'" + obj[column].replace("'", "''") + "'"

            elif (type(obj[column]) == int):
                strTranslatedValue = str(obj[column])
            
            else:
                strTranslatedValue = "NULL"
            
            valuesBuffer[column] = (strTranslatedValue)

        values = list(valuesBuffer.values())

        baseInsertStatement += "".join([value + (",\n\t" if index != len(values)-1 else "\n") for index, value in enumerate(values)]) + ")"

        baseInsertStatement += "\nON CONFLICT (Id) DO UPDATE SET\n\t" + "".join([(key + " = " + valuesBuffer[key] + (",\n\t" if index != len(columnOrder)-2 else "\n;\n")) if key != "IsActive" else "" for index, key in enumerate(columnOrder)])

        return baseInsertStatement
    

    return [generateInsertStatement(obj) for obj in objects]


def writeInsertLines(fileName: str, lines: list):
    f = open(fileName, 'w')
    f.writelines([i + '\n' for i in lines])
    f.close()


def produceMigrationFileFromObjects(tableName: str, objects: list):
    #We do not reference the objects from the global instance for this even though that 
    #is available for use for fk-dependent migrations, since not all migrations will end up 
    #writing to a global context.

    global migrationOrderNumber

    #Generating ids for each item, this will overwrite any passed in id
    objects = [{**obj, **{
        "Id": (index + 1),
        "IsActive": 1
    }} for index, obj in enumerate(objects)]

    lines = produceInsertStatementsForObjects(tableName, typeMetas[tableName], objects)
    writeInsertLines(migrationsBaseDir + '/' + str(migrationOrderNumber) + '__' + tableName + '.sql', lines)
    print(tableName + " migration successfully generated.")

    migrationOrderNumber += 1

    #There's some funkiness with adjusting a dynamic global list reference that's passed in as a param,
    #so we'll just return this back for the migration to update it with the explicit global reference
    return objects


def getForeignKeyIdForTitle(tableObjects: list, title: str):
    return next((x["Id"] for x in tableObjects if x["Title"] == title), None)

#endregion

#region Migration Producers

def regenerateDiceMigration():

    standardFaceCounts = [4, 6, 8, 10, 12, 20, 100]

    global dice

    dice = [
        {
            "Title": "d" + str(faceCount),
            "Minimum": 1,
            "Maximum": faceCount,
            "Description": "A " + str(faceCount) + "-sided dice"
        } for faceCount in standardFaceCounts]

    dice = produceMigrationFileFromObjects("DomainDice", dice)


def regenerateDomainDiceRollTypeMigration():
    
    global diceRollTypes

    diceRollTypes = [
        {
            "Title": "Attack"
        },
        {
            "Title": "Damage"
        },
        {
            "Title": "Initiative"
        },
        {
            "Title": "Check"
        },
        {
            "Title": "Save"
        },
    ]

    diceRollTypes = produceMigrationFileFromObjects("DomainDiceRollType", diceRollTypes)


def regenerateDomainDiceRollSubTypeMigration():
    
    global diceRollTypes
    global diceRollSubTypes

    diceRollTypes = [
        {
            "Title": "Melee Spell",
            "SuperType__DomainDiceRollType": getForeignKeyIdForTitle(diceRollTypes, "Attack")
        },
        {
            "Title": "Melee Damage",
            "SuperType__DomainDiceRollType": getForeignKeyIdForTitle(diceRollTypes, "Attack")
        },
        {
            "Title": "Ranged Spell",
            "SuperType__DomainDiceRollType": getForeignKeyIdForTitle(diceRollTypes, "Attack")
        },
        {
            "Title": "Ranged Damage",
            "SuperType__DomainDiceRollType": getForeignKeyIdForTitle(diceRollTypes, "Attack")
        },
        {
            "Title": "Sight",
            "SuperType__DomainDiceRollType": getForeignKeyIdForTitle(diceRollTypes, "Check")
        },
        {
            "Title": "Hearing",
            "SuperType__DomainDiceRollType": getForeignKeyIdForTitle(diceRollTypes, "Check")
        },
    ]

    diceRollTypes = produceMigrationFileFromObjects("DomainDiceRollSubType", diceRollSubTypes)


def regenerateBasicStatMigration():
    baseStatNames = ["Strength", "Dexterity", "Constitution", "Intelligence", "Wisdom", "Charisma"]

    global baseStats

    baseStats = [
        {
            "Title": title,
            "AbbreviatedTitle": title[:3].upper(),
            "IsBaseStat": 1,
        } for title in baseStatNames]

    baseStats.extend([
        {
            "Title": "Gold Amount",
            "AbbreviatedTitle": "Gold",
            "IsBaseStat": 0,
        },
        {
            "Title": "Movement Speed",
            "AbbreviatedTitle": "Speed",
            "IsBaseStat": 0,
        },
        {
            "Title": "Movement Used",
            "AbbreviatedTitle": "Moved",
            "IsBaseStat": 0,
        },
    ])

    baseStats = produceMigrationFileFromObjects("DomainCharacterStat", baseStats)


def regenerateActionsMigration():

    global actions
    global quantifiers

    actionTitles = [
        #Movement Actions
        "Move", "Climb", "Swim", "Crawl", "Stand Up", "Jump", 
        
        #Combat/Engagement Actions
        "Attack", "Grapple", "Shove", "Cast", "Dash", "Disengage", "Help", "Interact", "Use Item", "Equip", "Unequip", "Hide"
    ]

    actions = [{ "Title": title } for title in actionTitles]

    actions = produceMigrationFileFromObjects("DomainAction", actions)

    quantifiers.extend([
        {
            "DeltaPercentage": 0.5,
            "Target__DomainCharacterStat": getForeignKeyIdForTitle(conditions, "Movement Speed"),
            "Parent__DomainAction": getForeignKeyIdForTitle(conditions, "Climb")
        },
        {
            "DeltaPercentage": 0.5,
            "Target__DomainCharacterStat": getForeignKeyIdForTitle(conditions, "Movement Speed"),
            "Parent__DomainAction": getForeignKeyIdForTitle(conditions, "Swim")
        },
        {
            "DeltaPercentage": 0.5,
            "Target__DomainCharacterStat": getForeignKeyIdForTitle(conditions, "Movement Speed"),
            "Parent__DomainAction": getForeignKeyIdForTitle(conditions, "Crawl")
        },
        {
            "DeltaPercentage": 0.5,
            "Target__DomainCharacterStat": getForeignKeyIdForTitle(conditions, "Movement Available"),
            "Parent__DomainAction": getForeignKeyIdForTitle(conditions, "Stand Up")
        },
        {
            "IsAction": 1,
            "Parent__DomainAction": getForeignKeyIdForTitle(conditions, "Attack")
        },
        {
            "IsAction": 1,
            "Parent__DomainAction": getForeignKeyIdForTitle(conditions, "Grapple")
        },
        {
            "IsAction": 1,
            "Parent__DomainAction": getForeignKeyIdForTitle(conditions, "Shove")
        },
        {
            "IsAction": 1,
            "Parent__DomainAction": getForeignKeyIdForTitle(conditions, "Cast")
        },
        {
            "IsAction": 1,
            "Parent__DomainAction": getForeignKeyIdForTitle(conditions, "Dash")
        },
        {
            "DeltaPercentage": 2,
            "Target__DomainCharacterStat": getForeignKeyIdForTitle(conditions, "Movement Speed"),
            "Parent__DomainAction": getForeignKeyIdForTitle(conditions, "Dash")
        },
        {
            "IsAction": 1,
            "Parent__DomainAction": getForeignKeyIdForTitle(conditions, "Disengage")
        },
        {
            "IsAction": 1,
            "Parent__DomainAction": getForeignKeyIdForTitle(conditions, "Help")
        },
        {
            "IsAction": 1,
            "Parent__DomainAction": getForeignKeyIdForTitle(conditions, "Interact")
        },
        {
            "IsAction": 1,
            "Parent__DomainAction": getForeignKeyIdForTitle(conditions, "Use Item")
        },
        {
            "IsAction": 1,
            "Parent__DomainAction": getForeignKeyIdForTitle(conditions, "Equip")
        },
        {
            "IsAction": 1,
            "Parent__DomainAction": getForeignKeyIdForTitle(conditions, "Unequip")
        },
        {
            "IsAction": 1,
            "Parent__DomainAction": getForeignKeyIdForTitle(conditions, "Hide")
        },

    ])


def regenerateDomainClassMigration():
    
    global dice
    global classes
    global baseStats

    #Directly assigning values here since there's not really a convenient way to generate/map from a simpler collection for this
    classes = [
        {
            "Title": "Barbarian",
            "Description": "Barbarians are mighty warriors who are powered by primal forces of the multiverse that manifest as a Rage.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d12"),
        },
        {
            "Title": "Bard",
            "Description": "Bards are expert at inspiring others, soothing hurts, disheartening foes, and creating illusions.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d8"),
            "SpellcastingStat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Charisma")
        },
        {
            "Title": "Cleric",
            "Description": "Clerics can reach out to the divine magic of the Outer Planes and channel it to bolster people and battle foes.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d8"),
            "SpellcastingStat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Wisdom")
        },
        {
            "Title": "Druid",
            "Description": "Druids call on the forces of nature, harnessing magic to heal, transform into animals, and wield elemental destruction.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d8"),
            "SpellcastingStat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Wisdom")
        },
        {
            "Title": "Fighter",
            "Description": "Fighters all share an unparalleled prowess with weapons and armor, and are well acquainted with death, both meting it out and defying it.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d10"),
        },
        {
            "Title": "Monk",
            "Description": "Monks focus their internal reservoirs of power to create extraordinary, even supernatural, effects.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d8"),
        },
        {
            "Title": "Paladin",
            "Description": "Paladins live on the front lines of the cosmic struggle, united by their oaths against the forces of annihilation.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d10"),
            "SpellcastingStat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Charisma")
        },
        {
            "Title": "Ranger",
            "Description": "Rangers are honed with deadly focus and harness primal powers to protect the world from the ravages of monsters and tyrants.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d10"),
            "SpellcastingStat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Wisdom")
        },
        {
            "Title": "Rogue",
            "Description": "Rogues have a knack for finding the solution to just about any problem, prioritizing subtle strikes over brute strength.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d8"),
            "SpellcastingStat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Wisdom")
        },
        {
            "Title": "Sorcerer",
            "Description": "Sorcerers harness and channel the raw, roiling power of innate magic that is stamped into their very being.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d6"),
            "SpellcastingStat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Charisma")
        },
        {
            "Title": "Warlock",
            "Description": "Warlocks quest for knowledge that lies hidden in the fabric of the multiverse, piecing together arcane secrets to bolster their own power.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d8"),
            "SpellcastingStat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Charisma")
        },
        {
            "Title": "Wizard",
            "Description": "Wizards cast spells of explosive fire, arcing lightning, subtle deception, and spectacular transformations.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d6"),
            "SpellcastingStat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Intelligence")
        },
        {
            "Title": "Artificer",
            "Description": "Masters of invention, artificers use ingenuity and magic to unlock extraordinary capabilities in objects.",
            "HitDie__DomainDice": getForeignKeyIdForTitle(dice, "d8"),
            "SpellcastingStat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Intelligence")
        },
    ]

    classes = produceMigrationFileFromObjects("DomainClass", classes)


def regenerateDomainSubClassMigration():
    
    global classes
    global subClasses

    #For each subclass, associated quantifiers will be colocated instead of declaring all of each at once (for readability's sake)
    subClasses = [
        {
            "Title": "Path of the Berzerker",
            "AbbreviatedTitle": "Berzerker",
            "Description": "Barbarians who walk the Path of the Berserker direct their Rage primarily toward violence. Their path is one of untrammeled fury, and they thrill in the chaos of battle as they allow their Rage to seize and empower them.",
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Barbarian")
        },
        {
            "Title": "College of Lore",
            "AbbreviatedTitle": "Lore",
            "Description": "Bards of the College of Lore collect spells and secrets from diverse sources, such as scholarly tomes, mystical rites, and peasant tales. The college's members gather in libraries and universities to share their lore with one another. They also meet at festivals or affairs of state, where they can expose corruption, unravel lies, and poke fun at self-important figures of authority.",
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Bard")
        },
        {
            "Title": "Life Domain",
            "AbbreviatedTitle": "Life",
            "Description": "The Life Domain focuses on the positive energy that helps sustain all life in the multiverse. Clerics who tap into this domain are masters of healing, using that life force to cure many hurts.",
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Cleric")
        },
        {
            "Title": "Circle of the Land",
            "AbbreviatedTitle": "Land",
            "Description": "The Circle of the Land comprises mystics and sages who safeguard ancient knowledge and rites. These Druids meet within sacred circles of trees or standing stones to whisper primal secrets in Druidic. The circle’s wisest members preside as the chief priests of their communities.",
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Druid")
        },
        {
            "Title": "Champion",
            "AbbreviatedTitle": "Champion",
            "Description": "A Champion focuses on the development of martial prowess in a relentless pursuit of victory. Champions combine rigorous training with physical excellence to deal devastating blows, withstand peril, and garner glory. Whether in athletic contests or bloody battle, Champions strive for the crown of the victor.",
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Fighter")
        },
        {
            "Title": "Warrior of the Open Hand",
            "AbbreviatedTitle": "Open Hand",
            "Description": "Warriors of the Open Hand are masters of unarmed combat. They learn techniques to push and trip their opponents and manipulate their own energy to protect themselves from harm.",
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Monk")
        },
        {
            "Title": "Oath of Devotion",
            "AbbreviatedTitle": "Devotion",
            "Description": "The Oath of Devotion binds Paladins to the ideals of justice and order. These Paladins meet the archetype of the knight in shining armor. They hold themselves to the highest standards of conduct, and some—for better or worse—hold the rest of the world to the same standards.",
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Paladin")
        },
        {
            "Title": "Hunter",
            "AbbreviatedTitle": "Hunter",
            "Description": "You stalk prey in the wilds and elsewhere, using your abilities as a Hunter to protect nature and people everywhere from forces that would destroy them.",
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Ranger")
        },
        {
            "Title": "Thief",
            "AbbreviatedTitle": "Thief",
            "Description": "A mix of burglar, treasure hunter, and explorer, you are the epitome of an adventurer. In addition to improving your agility and stealth, you gain abilities useful for delving into ruins and getting maximum benefit from the magic items you find there.",
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Rogue")
        },
        {
            "Title": "Draconic Sorcery",
            "AbbreviatedTitle": "Draconic",
            "Description": "Your innate magic comes from the gift of a dragon. Perhaps an ancient dragon facing death bequeathed some of its magical power to you or your ancestor. You might have absorbed magic from a site infused with dragons’ power. Or perhaps you handled a treasure taken from a dragon’s hoard that was steeped in draconic power. Or you might have a dragon for an ancestor.",
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Sorcerer")
        },
        {
            "Title": "Fiend Patron",
            "AbbreviatedTitle": "Fiend Patron",
            "Description": "Your pact draws on the Lower Planes, the realms of perdition. You might forge a bargain with a demon lord such as Demogorgon or Orcus; an archdevil such as Asmodeus; or a pit fiend, balor, yugoloth, or night hag that is especially mighty. That patron’s aims are evil—the corruption or destruction of all things, ultimately including you—and your path is defined by the extent to which you strive against those aims.",
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Warlock")
        },
        {
            "Title": "Evoker",
            "AbbreviatedTitle": "Evoker",
            "Description": "Your studies focus on magic that creates powerful elemental effects such as bitter cold, searing flame, rolling thunder, crackling lightning, and burning acid. Some Evokers find employment in military forces, serving as artillery to blast armies from afar. Others use their power to protect others, while some seek their own gain.",
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Wizard")
        },
        {
            "Title": "Artillerist",
            "AbbreviatedTitle": "Artillerist",
            "Description": "You specialize in using magic to hurl energy, projectiles, and explosions on a battlefield. This destructive power is valued by armies in the wars on many different worlds, but some members of this specialization seek to build a more peaceful world by using their powers to fight the resurgence of strife.",
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Artificer")
        }
    ]

    classes = produceMigrationFileFromObjects("DomainSubClass", subClasses)


def regenerateDomainConditionsMigration():

    global baseStats
    global conditions
    global diceRollTypes
    global quantifiers

    conditions = [
        {
            "Title": "Blinded",
        },
        {
            "Title": "Charmed",
        },
        {
            "Title": "Deafened",
        },
        {
            "Title": "Exhausted",
        },
        {
            "Title": "Frightened",
        },
        {
            "Title": "Grappled",
        },
        {
            "Title": "Incapacitated",
        },
        {
            "Title": "Invisible",
        },
        {
            "Title": "Paralyzed",
        },
        {
            "Title": "Petrified",
        },
        {
            "Title": "Poisoned",
        },
        {
            "Title": "Prone",
        },
        {
            "Title": "Restrained",
        },
        {
            "Title": "Stunned",
        },
        {
            "Title": "Unconscious",
        },
        {
            "Title": "Enraged",
        },
        {
            "Title": "Wearing Heavy Armor",
        },
        {
            "Title": "Wearing Medium Armor",
        },
        {
            "Title": "Wearing Light Armor",
        },
    ]

    conditions = produceMigrationFileFromObjects("DomainCharacterStat", conditions)

    quantifiers.extend([
        #region Blinded
        {
            "AutomaticFailure": 1,
            "AppliesToTargets": 1,
            "Target__DomainDiceRollSubType": getForeignKeyIdForTitle(diceRollTypes, "Sight"),
            "Parent__DomainCondition": getForeignKeyIdForTitle(conditions, "Blinded")
        },
        {
            "GivesDisadvantage": 1,
            "AppliesToTargets": 1,
            "Target__DomainDiceRollType": getForeignKeyIdForTitle(diceRollTypes, "Attack"),
            "Parent__DomainCondition": getForeignKeyIdForTitle(conditions, "Blinded")
        },
        {
            "GivesAdvantage": 1,
            "AppliesAgainstTargets": 1,
            "Target__DomainDiceRollType": getForeignKeyIdForTitle(diceRollTypes, "Attack"),
            "Parent__DomainCondition": getForeignKeyIdForTitle(conditions, "Blinded")
        },
        #endregion

        #region Charmed
        {
            "Prevents": 1,
            "AppliesAgainstSourceForTargetsOnly": 1,
            "Target__DomainDiceRollType": getForeignKeyIdForTitle(diceRollTypes, "Attack"),
            "Parent__DomainCondition": getForeignKeyIdForTitle(conditions, "Charmed")
        },
        {
            "GivesAdvantage": 1,
            "AppliesAgainstTargetsForSourceOnly": 1,
            "Target__DomainDiceRollType": getForeignKeyIdForTitle(diceRollTypes, "Check"),
            "Target__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Charisma"),
            "Parent__DomainCondition": getForeignKeyIdForTitle(conditions, "Charmed")
        },
        {
            "GivesAdvantage": 1,
            "AppliesAgainstTargetsForSourceOnly": 1,
            "Target__DomainDiceRollType": getForeignKeyIdForTitle(diceRollTypes, "Check"),
            "Target__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Intelligence"),
            "Parent__DomainCondition": getForeignKeyIdForTitle(conditions, "Charmed")
        },
        {
            "GivesAdvantage": 1,
            "AppliesAgainstTargetsForSourceOnly": 1,
            "Target__DomainDiceRollType": getForeignKeyIdForTitle(diceRollTypes, "Check"),
            "Target__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Wisdom"),
            "Parent__DomainCondition": getForeignKeyIdForTitle(conditions, "Charmed")
        },
        #endregion
        
        #region Deafened
        {
            "AutomaticFailure": 1,
            "AppliesToTargets": 1,
            "Target__DomainDiceRollSubType": getForeignKeyIdForTitle(diceRollTypes, "Hearing"),
            "Parent__DomainCondition": getForeignKeyIdForTitle(conditions, "Deafened")
        },
        #endregion

        #region Frightened
        {
            "GivesAdvantage": 1,
            "AppliesAgainstTargetsForSourceOnly": 1,
            "Target__DomainDiceRollType": getForeignKeyIdForTitle(diceRollTypes, "Check"),
            "Target__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Charisma"),
            "Parent__DomainCondition": getForeignKeyIdForTitle(conditions, "Charmed")
        },
        {
            "Prevents": 1,
            "AppliesAgainstSourceForTargetsOnly": 1,
            "Target__DomainAction": getForeignKeyIdForTitle(diceRollTypes, "Move"),
            "Target__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Charisma"),
            "Parent__DomainCondition": getForeignKeyIdForTitle(conditions, "Charmed")
        },
        #endregion

    ])


def regenerateDomainClassTraitAndAssociatedQuantifiersMigration():
    
    global classes
    global subClasses
    global classTraits
    global quantifiers

    #region Barbarian 
    
    classTraits.extend([
        {
            "Title": "Rage",
            "AbbreviatedTitle": "Rage",
            "Description": "You can imbue yourself with a primal power called Rage, a force that grants you extraordinary might and resilience.",
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Barbarian")
        }
    ])

    #endregion

    classTraits = produceMigrationFileFromObjects("DomainClassTrait", classTraits)

    #region Quantifiers

    #region Barbarian

    quantifiers.extend([
        {
            "Quantity": 2,
            "LevelMinimumRequirement": 1,
            ""

            "ClassTrait__DomainClassTrait": getForeignKeyIdForTitle(classTraits, "Barbarian") 
        },
        #Rage is a bonus action if wearing heavy armor
        {

        }
    ])

    #endregion

    #endregion

    
def regenerateSavingThrowsMigration():

    global classes
    global baseStats

    savingThrows = [
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Barbarian"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Strength"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Barbarian"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Constitution"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Bard"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Dexterity"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Bard"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Charisma"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Cleric"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Wisdom"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Cleric"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Charisma"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Druid"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Intelligence"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Druid"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Wisdom"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Fighter"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Strength"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Fighter"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Constitution"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Monk"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Strength"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Monk"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Dexterity"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Paladin"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Wisdom"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Paladin"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Charisma"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Ranger"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Strength"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Ranger"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Dexterity"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Rogue"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Dexterity"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Rogue"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Intelligence"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Sorcerer"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Constitution"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Sorcerer"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Charisma"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Warlock"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Wisdom"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Warlock"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Charisma"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Wizard"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Intelligence"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Warlock"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Wisdom"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Artificer"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Constitution"),
        },
        {
            "Class__DomainClass": getForeignKeyIdForTitle(classes, "Artificer"),
            "Stat__DomainCharacterStat": getForeignKeyIdForTitle(baseStats, "Intelligence"),
        },
    ]

    savingThrows = produceMigrationFileFromObjects("ClassSave", savingThrows)
    

def regenerateSpellSchoolsMigration():

    global spellSchools

    spellSchools = [
        {
            "Title": "Abjuration",
        },
        {
            "Title": "Conjuration",
        },
        {
            "Title": "Divination",
        },
        {
            "Title": "Enchantment",
        },
        {
            "Title": "Evocation",
        },
        {
            "Title": "Illusion",
        },
        {
            "Title": "Necromancy",
        },
        {
            "Title": "Transmutation",
        },
    ]

    spellSchools = produceMigrationFileFromObjects("DomainSpellSchool", spellSchools)


def regenerateSpellsAndClassSpellsMigrations():

    global spellSchools
    global spells
    global classes

    #This will be populated separately with the generated list of spells classes have access to
    #for use in a separate generation step
    classSpellMappings = {}

    #region Non-Lambda Helpers

    def discernCastingTime(obj: dict, value: str):
        if "bonus" in value:
            return {**obj, **{"IsBonusAction": 1}}
        
        if "action" in value:
            return {**obj, **{"IsAction": 1}}
        
        if "minute" in value:
            return {**obj, **{"MinuteCastTime": int(re.sub("[^0-9]", "", value.split(" minute")[0]))}}

        if "hour" in value:
            return {**obj, **{"HourCastTime": int(re.sub("[^0-9]", "", value.split(" hour")[0]))}}
        
        return obj

    def discernDuration(obj: dict, value: str):
        if "Instantaneous" in value:
            return {**obj, **{"IsInstantaneous": 1}}
        
        if "round" in value:
            return {**obj, **{"RoundDuration": int(re.sub("[^0-9]", "", value.split(" round")[0]))}}
        
        if "minute" in value:
            return {**obj, **{"MinuteDuration": int(re.sub("[^0-9]", "", value.split(" minute")[0]))}}

        if "hour" in value:
            return {**obj, **{"HourDuration": int(re.sub("[^0-9]", "", value.split(" hour")[0]))}}
        
        if "day" in value:
            return {**obj, **{"DayDuration": int(re.sub("[^0-9]", "", value.split(" day")[0]))}}

        if "dispelled" in value:
            return {**obj, **{"LastsUntilDispelled": 1}}
        
        return obj

    def discernRange(obj: dict, value: str):
        if "Touch" in value:
            return {**obj, **{"RequiresTouch": 1}}
        
        if "Self" in value:
            return {**obj, **{"TargetsSelf": 1}}

        if "feet" in value:
            return {**obj, **{"RangeFeet": int(value.split(" feet")[0])}}

        if "mile" in value:
            return {**obj, **{"RangeMiles": int(value.split(" mile")[0])}}
        
        return obj

    def addClassSpellMapping(obj: dict, value: str):
        #Since this is a relationship for another table, update a separate list to work with
        #outside of the spell context while still being called through the same interface

        accessingClasses = value.split(",")

        for domainClass in accessingClasses:
            if (domainClass not in classSpellMappings):
                classSpellMappings[domainClass] = [obj["Title"]]
            else:
                classSpellMappings[domainClass].append(obj["Title"])

        return obj

    #endregion

    fieldTranslations = {
        "name": lambda obj, value: {**obj, **{"Title": value}},
        "level": lambda obj, value: {**obj, **{"LevelRequirement": int(value)}},
        "school": lambda obj, value: {**obj, **{"School__DomainSpellSchool": getForeignKeyIdForTitle(spellSchools, value)}},
        "V": lambda obj, value: {**obj, **{"HasVerbalRequirement": 0 if value == False else 1}},
        "S": lambda obj, value: {**obj, **{"HasSomaticRequirement": 0 if value == False else 1}},
        "M": lambda obj, value: {**obj, **{"MaterialComponent": None if str(value) == "nan" else str(value)}},
        "casting_time": discernCastingTime,
        "concentration": lambda obj, value: {**obj, **{"ConcentrationRequired": 0 if value == False else 1}},
        "duration": discernDuration,
        "range": discernRange,
        "ritual": lambda obj, value: {**obj, **{"IsRitual": 0 if value == False else 1}},
        "description": lambda obj, value: {**obj, **{"Description": value}},
        #ignoring higher level effect for now since that'll take some finagling
        "cast_higher": lambda obj, value: obj,
        "higher_levels": lambda obj, value: obj,
        "classes": addClassSpellMapping
    }

    #From https://github.com/TheDataRogue/dnd-5e-spells
    df = pd.read_excel("resources/D&D 5E Spells.xlsx")
    df = df.sort_values('name').reset_index().drop('index',axis=1)

    #This uploads to a global spell buffer, which will recieve generated ids for the 
    #class-spell mapping table migration to access within this same context (both are
    #sourced from the .xlsx file, so it makes sense to just keep the context within here)
    for index, row in df.iterrows():
        spellObjectBuffer = {}

        for field in fieldTranslations.keys():
            spellObjectBuffer = fieldTranslations[field](spellObjectBuffer, row[field])
        
        spells.append(spellObjectBuffer)
    
    spells = produceMigrationFileFromObjects("DomainSpell", spells)

    #Additionally generating the class-spell access context
    convertedClassSpellMappings = []

    for domainClass in classSpellMappings.keys():
        for spellTitle in classSpellMappings[domainClass]:
            convertedClassSpellMappings.append({
                "Class__DomainClass": getForeignKeyIdForTitle(classes, domainClass),
                "Spell__DomainSpell": getForeignKeyIdForTitle(spells, spellTitle)
            })

    produceMigrationFileFromObjects("ClassSpell", spellSchools)


def regenerateQuantifiersMigration():
    global quantifiers
    quantifiers = produceMigrationFileFromObjects("Quantifier", quantifiers)


#endregion


if __name__ == '__main__': main()