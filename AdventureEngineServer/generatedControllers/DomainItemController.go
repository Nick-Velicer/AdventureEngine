//*** CAUTION ***
//This is an autogenerated file produced by regenerateBackend.py.
//Edits made here will not persist after backend regeneration.

package generatedControllers
import (
   "errors"
   "fmt"
   "github.com/gin-gonic/gin/binding"
   "net/http"
   "regexp"
   "strconv"
   contextProviders "AdventureEngineServer/contextProviders"
   types "AdventureEngineServer/generatedDatabaseTypes"
   dtos "AdventureEngineServer/generatedDTOs"
   utils "AdventureEngineServer/utils"
)

func GetDomainItems(context *contextProviders.GeneratedControllerContext[types.DomainItem, dtos.DomainItemDTO, contextProviders.GetArgs[types.DomainItem], contextProviders.GetReturn[types.DomainItem]]) {
   if context == nil {
      panic("No controller context provided")
   }
   queryParams := context.RequestContext.Request.URL.Query()
   
   //Since we can have multiple filters, that sometimes doesn't play nicely with
   //Gin's parameter pulling, so they need to be isolated manually.
   re := regexp.MustCompile(`filter\[`)
   filterParams := make(map[string]string)
   for key, value := range queryParams {
      if re.MatchString(key) && len(value) == 1 {
         filterParams[key] = value[0]
      } else {
         fmt.Println("Unexpected filter configuration for " + key + ", skipping:")
         fmt.Println(value)
      }
   }
   
   parsedFilters := utils.ParseFilterURLExpression(filterParams)
   
   serviceBuffer, err := context.ServiceAction(&contextProviders.GetArgs[types.DomainItem]{ Filters: &parsedFilters })
   if err != nil {
      context.RequestContext.IndentedJSON(http.StatusInternalServerError, err.Error())
      return
   }
   
   var returnBuffer []dtos.DomainItemDTO
   for _, dbTypeInstance := range serviceBuffer {
      pointerToDTO, err := context.DTOConverter(&dbTypeInstance)
      if (err != nil) {
         context.RequestContext.IndentedJSON(http.StatusInternalServerError, err.Error())
         return
      }
      
      if (pointerToDTO == nil) {
         context.RequestContext.IndentedJSON(http.StatusInternalServerError, errors.New("DTO conversion resulted in nil for object of type DomainItem"))
         return
      }
      
      returnBuffer = append(returnBuffer, *pointerToDTO)
   }
   context.RequestContext.IndentedJSON(http.StatusOK, returnBuffer)
}

func GetDomainItemById(context *contextProviders.GeneratedControllerContext[types.DomainItem, dtos.DomainItemDTO, contextProviders.GetByIdArgs[types.DomainItem], contextProviders.GetByIdReturn[types.DomainItem]]) {
   if context == nil {
      panic("No controller context provided")
   }
   
   id := context.RequestContext.Param("id")
   idNum, err := strconv.Atoi(id)
   if err != nil {
      context.RequestContext.IndentedJSON(http.StatusInternalServerError, err.Error())
      return
   }
   serviceBuffer, err := context.ServiceAction(&contextProviders.GetByIdArgs[types.DomainItem]{ Id: idNum })
   if err != nil {
      context.RequestContext.IndentedJSON(http.StatusInternalServerError, err.Error())
      return
   }
   
   if serviceBuffer == nil {
      context.RequestContext.IndentedJSON(http.StatusOK, nil)
      return
   }
   
   returnBuffer, err := context.DTOConverter(serviceBuffer)
   
   if err != nil {
      context.RequestContext.IndentedJSON(http.StatusInternalServerError, err.Error())
      return
   }
   
   if (returnBuffer == nil) {
      context.RequestContext.IndentedJSON(http.StatusInternalServerError, errors.New("DTO conversion resulted in nil for object of type DomainItem"))
      return
   }
   context.RequestContext.IndentedJSON(http.StatusOK, returnBuffer)
}

func SaveDomainItem(context *contextProviders.GeneratedControllerContext[types.DomainItem, dtos.DomainItemDTO, contextProviders.SaveArgs[types.DomainItem], contextProviders.SaveReturn[types.DomainItem]]) {
   if context == nil {
      panic("No controller context provided")
   }
   
   //Weirdness with unmarshalling, cannot unmarshal into a nil pointer, there must be some pre-initialization somewhere along the line
   var DTOBuffer *dtos.DomainItemDTO = &dtos.DomainItemDTO{}
   var batchDTOBuffer []*dtos.DomainItemDTO
   var serviceBuffer []*types.DomainItem
   
   //If neither a single item nor a collection can be bound to JSON, fail early
   //ShouldBindBodyWith is used instead of ShouldBindJSON since the latter prevents multiple bind attempts
   if err := context.RequestContext.ShouldBindBodyWith(DTOBuffer, binding.JSON); err == nil {
      
      serviceBuffer = []*types.DomainItem{context.DTOFlattener(DTOBuffer)}
      serviceReturn, err := context.ServiceAction(&contextProviders.SaveArgs[types.DomainItem]{ Items: serviceBuffer })
      if err != nil {
         context.RequestContext.IndentedJSON(http.StatusInternalServerError, err.Error())
         return
      }
      
      returnBuffer, err := context.DTOConverter(serviceReturn[0])
      if err != nil {
         context.RequestContext.IndentedJSON(http.StatusInternalServerError, err.Error())
         return
      }
      
      if (returnBuffer == nil) {
         context.RequestContext.IndentedJSON(http.StatusInternalServerError, errors.New("DTO conversion resulted in nil for object of type DomainItem"))
         return
      }
      
      context.RequestContext.IndentedJSON(http.StatusOK, returnBuffer)
      return
      
   } else if err := context.RequestContext.ShouldBindBodyWith(&batchDTOBuffer, binding.JSON); err == nil {
      
      serviceBuffer = utils.Map(batchDTOBuffer, func(dto *dtos.DomainItemDTO) *types.DomainItem { return context.DTOFlattener(dto) })
      serviceReturn, err := context.ServiceAction(&contextProviders.SaveArgs[types.DomainItem]{ Items: serviceBuffer })
      if err != nil {
         context.RequestContext.IndentedJSON(http.StatusInternalServerError, err.Error())
         return
      }
      
      returnBuffer, err := utils.ErrorCompatibleMap(serviceReturn, func(dbReturn *types.DomainItem) (*dtos.DomainItemDTO, error) { return context.DTOConverter(dbReturn) })
      
      if err != nil {
         context.RequestContext.IndentedJSON(http.StatusInternalServerError, err.Error())
         return
      }
      
      context.RequestContext.IndentedJSON(http.StatusOK, returnBuffer)
      return
      
   } else {
      context.RequestContext.IndentedJSON(http.StatusBadRequest, err.Error())
      return
   }
}
