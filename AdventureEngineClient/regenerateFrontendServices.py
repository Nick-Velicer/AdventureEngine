import os
import re
import pprint

tsTypesDirectory = "types/coreTypes"
tsTypeImportsFile = "types/appTypes/appTypes"
serviceTargetDirectory = "services/generated"

autogeneratedWarningMessage = [
    '//*** CAUTION ***',
    '//This is an autogenerated file produced by regenerateFrontendServices.py.',
    '//Edits made here will not persist after regeneration.',
]

def indentLineBlock(lines: list):
        return ['   ' + line for line in lines]


def main():
    serviceTarget = os.path.dirname(serviceTargetDirectory)
    if not os.path.exists(serviceTarget):
        os.makedirs(serviceTarget)

    for file in os.listdir(tsTypesDirectory + "/"):
        fileName = os.fsdecode(file)

        if fileName.endswith('.ts'): 
            typeName = fileName.replace('.ts', '')
            fileLines = []
            try:
                fileLines = produceTSServiceFile(typeName)

            except Exception as e:
                raise e
            
            f = open(serviceTargetDirectory + "/" + typeName + "Service.ts", 'w')
            f.writelines([i + '\n' for i in fileLines])
            f.close()
    
    print("Frontend services successfully generated.")


#This requires all tablenames instead of being applied 1 by 1 as it is generating the full file managing all generated table endpoints
def produceTSServiceFile(typeName: str):
    #this should eventually be brought out to config
    baseApiUrl = "http://localhost:8080/"

    def produceGetCollectionMethod(tableName: str):
        lines = [
            'export async function get' + typeName + 's(filters?: FilterCollection<' + typeName + '>): Promise<' + typeName + '[]> {',
            *indentLineBlock([
                'try {',
                *indentLineBlock([
                    'const filterString = filters instanceof Array && filters?.length > 0? "?" + produceFilterParamsFromExpression(filters) : "";',
                    'const response = await fetch("' + baseApiUrl + 'get' + tableName + 's" + filterString, { credentials: "include" });',
                    'const returnObj = await response.json() as unknown as Array<' + typeName + '>;',
                    'return returnObj;'
                ]),
                '}',
                'catch (errors) {',
                *indentLineBlock([
                    'throw errors',
                ]),
                '}',
            ]),
            '}'
        ]

        return lines
    
    def produceGetItemByIdMethod(tableName: str):

        lines = [
            'export async function get' + typeName + 'byId(id: number): Promise<' + typeName + '> {',
            *indentLineBlock([
                'try {',
                *indentLineBlock([
                    'const response = await fetch("' + baseApiUrl + 'get' + tableName + '/" + id, { credentials: "include" });',
                    'const returnObj = await response.json() as unknown as ' + typeName + ';',
                    'return returnObj;'
                ]),
                '}',
                'catch (errors) {',
                *indentLineBlock([
                    'throw errors',
                ]),
                '}'
            ]),
            '}',
        ]

        return lines
    
    def produceSaveItemMethod(tableName: str):

        lines = [
            'export async function save' + typeName + '<T extends ' + typeName + ' | ' + typeName + '[]>(obj: T): Promise<T> {',
            *indentLineBlock([
                'try {',
                *indentLineBlock([
                    'const response = await fetch("' + baseApiUrl + 'save' + tableName + '", {method: "POST", headers: {"Content-Type": "application/json"}, body: JSON.stringify(obj), credentials: "include" });',
                    'const returnObj = await response.json() as unknown as T;',
                    'return returnObj;'
                ]),
                '}',
                'catch (errors) {',
                *indentLineBlock([
                    'throw errors',
                ]),
                '}'
            ]),
            '}',
        ]

        return lines

    lines = [
        *autogeneratedWarningMessage,
        '',
        'import { type ' + typeName + ' } from "../../' + tsTypeImportsFile + '";',
        'import { type FilterCollection, produceFilterParamsFromExpression} from "../filterUtils";',
        '',
        *produceGetCollectionMethod(typeName),
        '',
        *produceGetItemByIdMethod(typeName),
        '',
        *produceSaveItemMethod(typeName),
        '',
    ]

    return lines


if __name__ == '__main__': main()