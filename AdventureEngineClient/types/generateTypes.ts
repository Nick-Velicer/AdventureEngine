import { existsSync, mkdir, readdirSync, writeFile, writeFileSync } from "node:fs";
import { resolve } from "node:path";
import * as TJS from "typescript-json-schema";


const corePath = "./coreTypes";
const coreTypeFileNames = readdirSync(resolve(corePath));
const typeNames: Array<string> = coreTypeFileNames.map((fileName) => fileName.replace(".ts", ""));

const autogeneratedWarningMessage = `//*** CAUTION ***
//This is an autogenerated file produced by generateTypes.py.
//Edits made here will not persist after regeneration.`;

//Generating app type name constants (for some slightly cheaty Typescript)

const appTypesPath = "./appTypes";

if (!existsSync(appTypesPath)) {
	mkdir(appTypesPath, (err) => {
		if (err) {
			console.error("Error creating " + appTypesPath + ":", err);
		} else {
			console.log("Created " + appTypesPath);
		}
	});
}
else {
	console.log(appTypesPath + " already created.");
}

const appTypeImports = (typeNames: Array<string>) => {
	return ['import { SchemaObject } from "../SchemaObject";'].concat(typeNames.map((typeName) => {
		return 'import { ' + typeName + ' as Base__' + typeName + ' } from "../coreTypes/' + typeName + '";'
	})).join("\n");
}

const constantStructure = (typeNames: Array<string>) => {
	return ["const AppTypes = {"].concat(typeNames.map((typeName) => '	' + typeName + ': {} as ' + typeName + ',')).concat(["} as const satisfies Record<string, SchemaObject> "]).join("\n");
}

//This was initially in SchemaObject.ts, but since it only deals with this final type sanitization scope,
//it makes sense to group it in with the final app type api
const recursionGuardedType = `
//This prevents any circular relationships from initializing infinitely, even though Typescript
//will allow that sort of type recursion (this mirrors the backend's circular relationship checks)
type RecursionGuardedSchemaObject<T extends SchemaObject, G extends (typeof AppTypes[keyof typeof AppTypes]) = undefined> = [T] extends [G]? 
	//Circular catch case if the type is in our "seen before" union (with a tuple wrap to interpret the "extends any of the stuff in this union" conditional properly)
	undefined
	:
	{
		Id: T["Id"],
		Attributes: T["Attributes"],
		Relationships: {
			ManyToOne: {[key in keyof T["Relationships"]["ManyToOne"]]: RecursionGuardedSchemaObject<T["Relationships"]["ManyToOne"][key], G extends undefined? T : G | T>},
			//Extra handling to have the circular catch case resolve as undefined instead of undefined[]
			OneToMany: {[key in keyof T["Relationships"]["OneToMany"]]: RecursionGuardedSchemaObject<T["Relationships"]["OneToMany"][key][number], G extends undefined? T : G | T> extends undefined? 
				undefined 
				: 
				RecursionGuardedSchemaObject<T["Relationships"]["OneToMany"][key][number], G extends undefined? T : G | T>[]
			},
		}
	}`;

const appTypes = (typeNames: Array<string>) => {
	return typeNames.map((typeName) => {
		return 'export type ' + typeName + ' = RecursionGuardedSchemaObject<Base__' + typeName + '>;'
	}).join("\n");
}

writeFileSync(appTypesPath + "/appTypes.ts", (
	autogeneratedWarningMessage + 
	"\n" +
	appTypeImports(typeNames) + 
	"\n\n" + 
	constantStructure(typeNames) + 
	"\n" + 
	recursionGuardedType +
	"\n\n" +
	appTypes(typeNames)
));



//Generating flattened types (everything on one object level and relationships reduced to their id's)

const flattenedPath = "./flattenedTypes";

if (!existsSync(flattenedPath)) {
	mkdir(flattenedPath, (err) => {
		if (err) {
			console.error("Error creating " + flattenedPath + ":", err);
		} else {
			console.log("Created " + flattenedPath);
		}
	});
}
else {
	console.log(flattenedPath + " already created.");
}

const flattenedTypeImports = (typeNames: Array<string>) => {
	return [
		autogeneratedWarningMessage,
		'import { FlattenedSchemaObject } from "../SchemaObject";'
	].concat(typeNames.map((typeName) => {
		return 'import { ' + typeName + ' } from "../coreTypes/' + typeName + '";'
	})).concat([
		'import { Simplify } from "type-fest";'
	]).join("\n");
}

const flattenedTypes = (typeNames: Array<string>) => {
	return typeNames.map((typeName) => 'export type Flattened' + typeName + ' = Simplify<FlattenedSchemaObject<' + typeName + '>>;' ).join("\n");
}

writeFileSync(flattenedPath + "/flattenedTypes.ts", flattenedTypeImports(typeNames) + "\n\n" + flattenedTypes(typeNames))

//Generating json schemas from the flattened types

const generatedFilesBasePath = "./generated";

const settings: TJS.PartialArgs = {
	required: true
};

const compilerOptions: TJS.CompilerOptions = {
	strictNullChecks: true,
};

if (!existsSync(generatedFilesBasePath)) {
	mkdir(generatedFilesBasePath, (err) => {
		if (err) {
			throw new Error("Error creating " + generatedFilesBasePath + ":");
		}
	});
}
console.log(generatedFilesBasePath + " path verified.");

const flattenedFileTarget = "flattenedTypes.ts"

const program = TJS.getProgramFromFiles([resolve(flattenedPath + "/" + flattenedFileTarget)], compilerOptions);

console.log("TJS program initialized.");

const generator = TJS.buildGenerator(program, settings);

console.log("TJS schema generator initialized");

if (generator == null) {
	throw new Error("Error creating TJS generator for program " + flattenedPath + "/" + flattenedFileTarget);
}

const schemas = Object.fromEntries(typeNames.map((type) => "Flattened" + type).map((flattenedTypeName) => {
	console.log("Successfully translated " + flattenedTypeName + " schema.")
	return ([
		flattenedTypeName,
		TJS.generateSchema(program!, flattenedTypeName, settings, [], generator)
	]);
}));



Object.keys(schemas).forEach((schemaName) => {
	writeFile(
		generatedFilesBasePath + "/" + schemaName.replace("Flattened", "") + ".json", 
		JSON.stringify(schemas[schemaName], null, 4),
		() => {
			console.log("Successfully generated " + schemaName.replace("Flattened", "") + " schema.")
		}
	);
})


