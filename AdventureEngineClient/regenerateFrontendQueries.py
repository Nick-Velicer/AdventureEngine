import os
import re
import pprint

tsTypesDirectory = "types/coreTypes"
tsTypeImportsFile = "types/appTypes/appTypes"
queriesTargetDirectory = "queries/"
typeNames = [os.fsdecode(file).replace('.ts', '') for file in os.listdir(tsTypesDirectory + "/")]

autogeneratedWarningMessage = [
    '//*** CAUTION ***',
    '//This is an autogenerated file produced by regenerateFrontendQueries.py.',
    '//Edits made here will not persist after regeneration.',
]

def indentLineBlock(lines: list):
        return ['   ' + line for line in lines]


def main():
    queriesTarget = os.path.dirname(queriesTargetDirectory)
    if not os.path.exists(queriesTarget):
        os.makedirs(queriesTarget)
    
    fileLines = [
        *autogeneratedWarningMessage,
        '',
        'import { AppTypes } from "../' + tsTypeImportsFile + '";',
        'import type { SchemaObject } from "../types/SchemaObject";',
        '',
        'export type ServiceInterface<T> = {',
        *indentLineBlock([
            'getAllItems: () => Promise<Array<T>>',
            'getItemById: (id: number) => Promise<T>',
            'saveItem: <G extends T | T[]>(item: G) => Promise<G>'
        ]),
        '}',
        '',
        'export type QueryServicesType = {[key in keyof typeof AppTypes]: ServiceInterface<typeof AppTypes[key]>}',
        '',
        'export function composeQueryBuilderContext<',
        *indentLineBlock([
            'T extends <G extends SchemaObject>(opts: {',
            *indentLineBlock([
                'key: string[],',
                'query: (...args : any[]) => Promise<G | G[]>',
            ]),
            '}) => ReturnType<T>,',
            'U extends <G extends SchemaObject>(opts: {',
            *indentLineBlock([
                'mutation: (...args : any[]) => Promise<G>',
                'onSettled: () => any',
                '//Eventually a more general onSuccess interface name would be nice',
                '//but for now this is a reasonable expectation and saves some headache',
                '//from having an extra translation step when the Pinia handlers are injected.'
            ]),
            '}) => ReturnType<U>,',
            'C extends () => ReturnType<C>,',
            'Q extends (cacheContext: ReturnType<C>, keys: string[]) => any,',
        ]),
        '>(',
        *indentLineBlock([
            'queryHandler: T,', 
            'mutationHandler: U,',
            'cacheHandler: C,'
            'queryInvalidator: Q,',
            'services: QueryServicesType'
        ]),
        ') {',
        *indentLineBlock([
            'return {',
            *indentLineBlock([
                *[item for sublist in [produceQueryLinesForType(typeName) for typeName in typeNames] for item in sublist],
            ]),
            '}'
        ]),
        '}'    
    ]
            
    f = open(queriesTargetDirectory + "/queries.ts", 'w')
    f.writelines([i + '\n' for i in fileLines])
    f.close()
    
    print("Frontend query builders successfully generated.")


def produceQueryLinesForType(typeName: str):
    #this should eventually be brought out to config
    baseApiUrl = "http://localhost:8080/"

    def produceGetCollectionQuery(tableName: str):
        lines = [
            'useGet' + tableName + 'sQuery: () => queryHandler({',
                *indentLineBlock([
                    'key: ["get' + tableName + 's"],',
                    'query: () => services.' + tableName + '.getAllItems()',
                ]),
            '}),',
        ]

        return lines
    
    def produceGetItemByIdQuery(tableName: str):
        lines = [
            'useGet' + tableName + 'ByIdQuery: (id: number) => {',
            *indentLineBlock([
                '//For some reason queries with args does not work without the extra function body/return.',
                '//Not a huge deal, but apparently a Colada quirk for dynamic-ish queries',
                'return queryHandler({',
                *indentLineBlock([
                    'key: ["get' + tableName + 'ById", id.toString()],',
                    'query: () => services.' + tableName + '.getItemById(id)',
                ]),
                '});'
            ]),
            '},',
        ]

        return lines
    
    def produceSaveItemMutation(tableName: str):
        lines = [
            'useSave' + tableName + 'Mutation: (obj: Parameters<typeof services.' + tableName + '.saveItem>[0]) => {',
            *indentLineBlock([
                'const queryCache = cacheHandler();',
                'return mutationHandler({',
                *indentLineBlock([
                    'mutation: () => services.' + tableName + '.saveItem(obj),',
                    'onSettled: async () => queryInvalidator(queryCache, ["get' + tableName + 's", "get' + tableName + 'ById"])'
                ]),
                '});'
            ]),
            '},',
        ]

        return lines

    lines = [
        '//' + typeName,
        *produceGetCollectionQuery(typeName),
        *produceGetItemByIdQuery(typeName),
        *produceSaveItemMutation(typeName),
        ''
    ]

    return lines


if __name__ == '__main__': main()