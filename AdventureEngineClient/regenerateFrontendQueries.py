import os
import re
import pprint
import json

typeMetas = {}

tsTypesDirectory = "types/coreTypes"
tsTypeImportsFile = "types/appTypes/appTypes"
jsonSchemaImportDirectory = "types/generated"
queriesTargetDirectory = "queries/"
typeNames = [os.fsdecode(file).replace('.ts', '') for file in os.listdir(tsTypesDirectory + "/")]

autogeneratedWarningMessage = [
    '//*** CAUTION ***',
    '//This is an autogenerated file produced by regenerateFrontendQueries.py.',
    '//Edits made here will not persist after regeneration.',
]

def indentLineBlock(lines: list):
        return ['   ' + line for line in lines]


def main():
    queriesTarget = os.path.dirname(queriesTargetDirectory)
    if not os.path.exists(queriesTarget):
        os.makedirs(queriesTarget)
    
    for file in os.listdir(jsonSchemaImportDirectory + "/"):
        fileName = os.fsdecode(file)
        typeMetas[fileName.split(".")[0]] = produceParsedType(jsonSchemaImportDirectory + "/" + fileName)

    print("Successfully parsed schemas.")

    fileLines = [
        *autogeneratedWarningMessage,
        '',
        'import { AppTypes } from "../' + tsTypeImportsFile + '";',
        'import type { SchemaObject } from "../types/SchemaObject";',
        '',
        'export type ServiceInterface<T> = {',
        *indentLineBlock([
            'getAllItems: (...params: any) => Promise<Array<T>>',
            'getItemById: (id: number) => Promise<T>',
            'saveItem: <G extends T | T[]>(item: G) => Promise<G>'
        ]),
        '}',
        '',
        'export type QueryServicesType = {[key in keyof typeof AppTypes]: ServiceInterface<typeof AppTypes[key]>}',
        '',
        'export function composeQueryBuilderContext<',
        *indentLineBlock([
            'T extends <G extends SchemaObject>(opts: {',
            *indentLineBlock([
                'key: string[],',
                'query: (...args : any[]) => Promise<G | G[]>',
            ]),
            '}) => ReturnType<T>,',
            'U extends <G extends SchemaObject>(opts: {',
            *indentLineBlock([
                'mutation: (...args : any[]) => Promise<G>',
                'onSuccess: (data: G | G[], ...args: any[]) => any',
            ]),
            '}) => ReturnType<U>,',
            'C extends () => ReturnType<C>,',
            'Q extends (cacheContext: ReturnType<C>, keys: string[]) => any,',
        ]),
        '>(',
        *indentLineBlock([
            'queryHandler: T,', 
            'mutationHandler: U,',
            'cacheHandler: C,'
            'queryInvalidator: Q,',
            'services: QueryServicesType'
        ]),
        ') {',
        *indentLineBlock([
            'return {',
            *indentLineBlock([
                *[item for sublist in [produceQueryLinesForType(typeName, typeMetas[typeName]) for typeName in typeNames] for item in sublist],
            ]),
            '}'
        ]),
        '}'    
    ]
            
    f = open(queriesTargetDirectory + "/generatedQueries.ts", 'w')
    f.writelines([i + '\n' for i in fileLines])
    f.close()
    
    print("Frontend query builders successfully generated.")


#This is a frontend variation of the backend utility that pulls from the generated JSON
#If needed it can be moved out to another file, but currently only the query generation needs it
def produceParsedType(fileName: str):
    schemaData = ''

    try:
        with open(fileName, 'r') as file:
            schemaData = json.load(file)

    except FileNotFoundError:
        raise FileNotFoundError('Error: The file ' + fileName + ' was not found.')
    
    except Exception as e:
        raise e
    
    if (schemaData == ''):
        raise Exception('Unexpected: could not recieve file content from ' + fileName)

    typeMeta = {
        'attributes': {}, 
        'relationships': {
            'manyToOne': {},
            'oneToMany': {}
        }
    }

    for key in schemaData["properties"]:
        #If a relationship field
        if "__" in key:
            correspondingTableText: str = key.split('__')[1]
            capitalizedTableName: str = correspondingTableText[0].upper() + correspondingTableText[1:]

            #One-to-many relationship
            if (schemaData["properties"][key]["type"] == "array"):
                typeMeta["relationships"]["oneToMany"][key] = {
                    "type": schemaData["properties"][key]["type"],
                    "correspondingTable": capitalizedTableName
                }

            #Many-to-one relationship
            else:
                typeMeta["relationships"]["manyToOne"][key] = {
                    "type": schemaData["properties"][key]["type"],
                    "correspondingTable": capitalizedTableName
                }

        #Otherwise an attribute field
        elif (key != "Id"):
            typeMeta["attributes"][key] = {
                "type": schemaData["properties"][key]["type"]
            }

    #resulting dict structure for a type/table:
    #{
    #   'attributes': {
    #       'field': {
    #           'type': 'type'
    #       }
    #   }
    #
    #   'relationships': {
    #       'oneToMany': {
    #           'field': {
    #             'type': 'type'
    #             'correspondingTable': 'tableName'
    #            }
    #       }
    #       'manyToOne': {
    #           'field': {
    #             'type': 'type'
    #             'correspondingTable': 'tableName'
    #            }
    #       }
    #       
    #   }
    #}

    return typeMeta

def produceQueryLinesForType(typeName: str, typeMeta: dict):

    #this should eventually be brought out to config
    baseApiUrl = "http://localhost:8080/"

    def produceGetCollectionQuery(tableName: str):
        lines = [
            'useGet' + tableName + 'sQuery: <H extends Parameters<typeof services.' + tableName + '.getAllItems>>(...params: H) => {',
            *indentLineBlock([
                'return queryHandler({',
                *indentLineBlock([
                    'key: ["get' + tableName + 's", params?.toString()],',
                    'query: () => services.' + tableName + '.getAllItems(...params)',
                ]),
                '});'
            ]),
            '},',
        ]

        return lines
    
    def produceGetItemByIdQuery(tableName: str):
        lines = [
            'useGet' + tableName + 'ByIdQuery: (id: number) => {',
            *indentLineBlock([
                'return queryHandler({',
                *indentLineBlock([
                    'key: ["get' + tableName + 'ById", id.toString()],',
                    'query: () => services.' + tableName + '.getItemById(id)',
                ]),
                '});'
            ]),
            '},',
        ]

        return lines
    
    def produceSaveItemMutation(tableName: str):
        lines = [
            'useSave' + tableName + 'Mutation: <H extends Parameters<typeof services.' + tableName + '.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {',
            *indentLineBlock([
                'const queryCache = cacheHandler();',
                'return mutationHandler({',
                *indentLineBlock([
                    'mutation: () => services.' + tableName + '.saveItem(obj),',
                    'onSuccess: async (data: H, ...args) => {',
                    *indentLineBlock([
                        '//This is a standin for ".then(value => ...)" since for SOME reason mutations don\'t allow you to get the value back directly',
                        'onSuccess(data);',
                        'queryInvalidator(queryCache, [',
                        *indentLineBlock([
                            '"get' + tableName + 's",',
                            '"get' + tableName + 'ById",',
                            *['"get' + relationship.split("__")[1] + 's",' for relationship in typeMeta["relationships"]["manyToOne"]],
                            *['"get' + relationship.split("__")[1] + 'ById",' for relationship in typeMeta["relationships"]["manyToOne"]],
                        ]),
                        ']);',
                    ]),
                    '}'
                ]),
                '});'
            ]),
            '},',
        ]

        return lines

    lines = [
        '//' + typeName,
        *produceGetCollectionQuery(typeName),
        *produceGetItemByIdQuery(typeName),
        *produceSaveItemMutation(typeName),
        ''
    ]

    return lines


if __name__ == '__main__': main()