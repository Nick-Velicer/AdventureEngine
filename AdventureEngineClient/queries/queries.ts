//*** CAUTION ***
//This is an autogenerated file produced by regenerateFrontendQueries.py.
//Edits made here will not persist after regeneration.

import { AppTypes } from "../types/appTypes/appTypes";
import type { SchemaObject } from "../types/SchemaObject";

export type ServiceInterface<T> = {
   getAllItems: () => Promise<Array<T>>
   getItemById: (id: number) => Promise<T>
   saveItem: (item: T) => Promise<T>
}

export type QueryServicesType = {[key in keyof typeof AppTypes]: ServiceInterface<typeof AppTypes[key]>}

export function composeQueryBuilderContext<
   T extends <G extends SchemaObject>(opts: {
      key: string[],
      query: (...args : any[]) => Promise<G | G[]>
   }) => ReturnType<T>,
   U extends <G extends SchemaObject>(opts: {
      mutation: (...args : any[]) => Promise<G>
      onSettled: () => any
      //Eventually a more general onSuccess interface name would be nice
      //but for now this is a reasonable expectation and saves some headache
      //from having an extra translation step when the Pinia handlers are injected.
   }) => ReturnType<U>,
   C extends () => ReturnType<C>,
   Q extends (cacheContext: ReturnType<C>, keys: string[]) => any,
>(
   queryHandler: T,
   mutationHandler: U,
   cacheHandler: C,queryInvalidator: Q,
   services: QueryServicesType
) {
   return {
      //Campaign
      useGetCampaignsQuery: () => queryHandler({
         key: ["getCampaigns"],
         query: () => services.Campaign.getAllItems()
      }),
      useGetCampaignByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getCampaignById", id.toString()],
            query: () => services.Campaign.getItemById(id)
         });
      },
      useSaveCampaignMutation: (obj: Parameters<typeof services.Campaign.saveItem>[0]) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.Campaign.saveItem(obj),
            onSettled: async () => queryInvalidator(queryCache, ["getCampaigns", "getCampaignById"])
         });
      },
      
      //Character
      useGetCharactersQuery: () => queryHandler({
         key: ["getCharacters"],
         query: () => services.Character.getAllItems()
      }),
      useGetCharacterByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getCharacterById", id.toString()],
            query: () => services.Character.getItemById(id)
         });
      },
      useSaveCharacterMutation: (obj: Parameters<typeof services.Character.saveItem>[0]) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.Character.saveItem(obj),
            onSettled: async () => queryInvalidator(queryCache, ["getCharacters", "getCharacterById"])
         });
      },
      
      //CharacterDomainCharacterStatInstance
      useGetCharacterDomainCharacterStatInstancesQuery: () => queryHandler({
         key: ["getCharacterDomainCharacterStatInstances"],
         query: () => services.CharacterDomainCharacterStatInstance.getAllItems()
      }),
      useGetCharacterDomainCharacterStatInstanceByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getCharacterDomainCharacterStatInstanceById", id.toString()],
            query: () => services.CharacterDomainCharacterStatInstance.getItemById(id)
         });
      },
      useSaveCharacterDomainCharacterStatInstanceMutation: (obj: Parameters<typeof services.CharacterDomainCharacterStatInstance.saveItem>[0]) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.CharacterDomainCharacterStatInstance.saveItem(obj),
            onSettled: async () => queryInvalidator(queryCache, ["getCharacterDomainCharacterStatInstances", "getCharacterDomainCharacterStatInstanceById"])
         });
      },
      
      //ClassPrimaryAbility
      useGetClassPrimaryAbilitysQuery: () => queryHandler({
         key: ["getClassPrimaryAbilitys"],
         query: () => services.ClassPrimaryAbility.getAllItems()
      }),
      useGetClassPrimaryAbilityByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getClassPrimaryAbilityById", id.toString()],
            query: () => services.ClassPrimaryAbility.getItemById(id)
         });
      },
      useSaveClassPrimaryAbilityMutation: (obj: Parameters<typeof services.ClassPrimaryAbility.saveItem>[0]) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.ClassPrimaryAbility.saveItem(obj),
            onSettled: async () => queryInvalidator(queryCache, ["getClassPrimaryAbilitys", "getClassPrimaryAbilityById"])
         });
      },
      
      //ClassSave
      useGetClassSavesQuery: () => queryHandler({
         key: ["getClassSaves"],
         query: () => services.ClassSave.getAllItems()
      }),
      useGetClassSaveByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getClassSaveById", id.toString()],
            query: () => services.ClassSave.getItemById(id)
         });
      },
      useSaveClassSaveMutation: (obj: Parameters<typeof services.ClassSave.saveItem>[0]) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.ClassSave.saveItem(obj),
            onSettled: async () => queryInvalidator(queryCache, ["getClassSaves", "getClassSaveById"])
         });
      },
      
      //ClassSpell
      useGetClassSpellsQuery: () => queryHandler({
         key: ["getClassSpells"],
         query: () => services.ClassSpell.getAllItems()
      }),
      useGetClassSpellByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getClassSpellById", id.toString()],
            query: () => services.ClassSpell.getItemById(id)
         });
      },
      useSaveClassSpellMutation: (obj: Parameters<typeof services.ClassSpell.saveItem>[0]) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.ClassSpell.saveItem(obj),
            onSettled: async () => queryInvalidator(queryCache, ["getClassSpells", "getClassSpellById"])
         });
      },
      
      //DomainAction
      useGetDomainActionsQuery: () => queryHandler({
         key: ["getDomainActions"],
         query: () => services.DomainAction.getAllItems()
      }),
      useGetDomainActionByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainActionById", id.toString()],
            query: () => services.DomainAction.getItemById(id)
         });
      },
      useSaveDomainActionMutation: (obj: Parameters<typeof services.DomainAction.saveItem>[0]) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainAction.saveItem(obj),
            onSettled: async () => queryInvalidator(queryCache, ["getDomainActions", "getDomainActionById"])
         });
      },
      
      //DomainCharacterStat
      useGetDomainCharacterStatsQuery: () => queryHandler({
         key: ["getDomainCharacterStats"],
         query: () => services.DomainCharacterStat.getAllItems()
      }),
      useGetDomainCharacterStatByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainCharacterStatById", id.toString()],
            query: () => services.DomainCharacterStat.getItemById(id)
         });
      },
      useSaveDomainCharacterStatMutation: (obj: Parameters<typeof services.DomainCharacterStat.saveItem>[0]) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainCharacterStat.saveItem(obj),
            onSettled: async () => queryInvalidator(queryCache, ["getDomainCharacterStats", "getDomainCharacterStatById"])
         });
      },
      
      //DomainClass
      useGetDomainClasssQuery: () => queryHandler({
         key: ["getDomainClasss"],
         query: () => services.DomainClass.getAllItems()
      }),
      useGetDomainClassByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainClassById", id.toString()],
            query: () => services.DomainClass.getItemById(id)
         });
      },
      useSaveDomainClassMutation: (obj: Parameters<typeof services.DomainClass.saveItem>[0]) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainClass.saveItem(obj),
            onSettled: async () => queryInvalidator(queryCache, ["getDomainClasss", "getDomainClassById"])
         });
      },
      
      //DomainCondition
      useGetDomainConditionsQuery: () => queryHandler({
         key: ["getDomainConditions"],
         query: () => services.DomainCondition.getAllItems()
      }),
      useGetDomainConditionByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainConditionById", id.toString()],
            query: () => services.DomainCondition.getItemById(id)
         });
      },
      useSaveDomainConditionMutation: (obj: Parameters<typeof services.DomainCondition.saveItem>[0]) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainCondition.saveItem(obj),
            onSettled: async () => queryInvalidator(queryCache, ["getDomainConditions", "getDomainConditionById"])
         });
      },
      
      //DomainCreatureType
      useGetDomainCreatureTypesQuery: () => queryHandler({
         key: ["getDomainCreatureTypes"],
         query: () => services.DomainCreatureType.getAllItems()
      }),
      useGetDomainCreatureTypeByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainCreatureTypeById", id.toString()],
            query: () => services.DomainCreatureType.getItemById(id)
         });
      },
      useSaveDomainCreatureTypeMutation: (obj: Parameters<typeof services.DomainCreatureType.saveItem>[0]) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainCreatureType.saveItem(obj),
            onSettled: async () => queryInvalidator(queryCache, ["getDomainCreatureTypes", "getDomainCreatureTypeById"])
         });
      },
      
      //DomainDamageType
      useGetDomainDamageTypesQuery: () => queryHandler({
         key: ["getDomainDamageTypes"],
         query: () => services.DomainDamageType.getAllItems()
      }),
      useGetDomainDamageTypeByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainDamageTypeById", id.toString()],
            query: () => services.DomainDamageType.getItemById(id)
         });
      },
      useSaveDomainDamageTypeMutation: (obj: Parameters<typeof services.DomainDamageType.saveItem>[0]) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainDamageType.saveItem(obj),
            onSettled: async () => queryInvalidator(queryCache, ["getDomainDamageTypes", "getDomainDamageTypeById"])
         });
      },
      
      //DomainDice
      useGetDomainDicesQuery: () => queryHandler({
         key: ["getDomainDices"],
         query: () => services.DomainDice.getAllItems()
      }),
      useGetDomainDiceByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainDiceById", id.toString()],
            query: () => services.DomainDice.getItemById(id)
         });
      },
      useSaveDomainDiceMutation: (obj: Parameters<typeof services.DomainDice.saveItem>[0]) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainDice.saveItem(obj),
            onSettled: async () => queryInvalidator(queryCache, ["getDomainDices", "getDomainDiceById"])
         });
      },
      
      //DomainDiceRollType
      useGetDomainDiceRollTypesQuery: () => queryHandler({
         key: ["getDomainDiceRollTypes"],
         query: () => services.DomainDiceRollType.getAllItems()
      }),
      useGetDomainDiceRollTypeByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainDiceRollTypeById", id.toString()],
            query: () => services.DomainDiceRollType.getItemById(id)
         });
      },
      useSaveDomainDiceRollTypeMutation: (obj: Parameters<typeof services.DomainDiceRollType.saveItem>[0]) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainDiceRollType.saveItem(obj),
            onSettled: async () => queryInvalidator(queryCache, ["getDomainDiceRollTypes", "getDomainDiceRollTypeById"])
         });
      },
      
      //DomainItem
      useGetDomainItemsQuery: () => queryHandler({
         key: ["getDomainItems"],
         query: () => services.DomainItem.getAllItems()
      }),
      useGetDomainItemByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainItemById", id.toString()],
            query: () => services.DomainItem.getItemById(id)
         });
      },
      useSaveDomainItemMutation: (obj: Parameters<typeof services.DomainItem.saveItem>[0]) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainItem.saveItem(obj),
            onSettled: async () => queryInvalidator(queryCache, ["getDomainItems", "getDomainItemById"])
         });
      },
      
      //DomainSize
      useGetDomainSizesQuery: () => queryHandler({
         key: ["getDomainSizes"],
         query: () => services.DomainSize.getAllItems()
      }),
      useGetDomainSizeByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainSizeById", id.toString()],
            query: () => services.DomainSize.getItemById(id)
         });
      },
      useSaveDomainSizeMutation: (obj: Parameters<typeof services.DomainSize.saveItem>[0]) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainSize.saveItem(obj),
            onSettled: async () => queryInvalidator(queryCache, ["getDomainSizes", "getDomainSizeById"])
         });
      },
      
      //DomainSpecies
      useGetDomainSpeciessQuery: () => queryHandler({
         key: ["getDomainSpeciess"],
         query: () => services.DomainSpecies.getAllItems()
      }),
      useGetDomainSpeciesByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainSpeciesById", id.toString()],
            query: () => services.DomainSpecies.getItemById(id)
         });
      },
      useSaveDomainSpeciesMutation: (obj: Parameters<typeof services.DomainSpecies.saveItem>[0]) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainSpecies.saveItem(obj),
            onSettled: async () => queryInvalidator(queryCache, ["getDomainSpeciess", "getDomainSpeciesById"])
         });
      },
      
      //DomainSpell
      useGetDomainSpellsQuery: () => queryHandler({
         key: ["getDomainSpells"],
         query: () => services.DomainSpell.getAllItems()
      }),
      useGetDomainSpellByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainSpellById", id.toString()],
            query: () => services.DomainSpell.getItemById(id)
         });
      },
      useSaveDomainSpellMutation: (obj: Parameters<typeof services.DomainSpell.saveItem>[0]) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainSpell.saveItem(obj),
            onSettled: async () => queryInvalidator(queryCache, ["getDomainSpells", "getDomainSpellById"])
         });
      },
      
      //DomainSpellSchool
      useGetDomainSpellSchoolsQuery: () => queryHandler({
         key: ["getDomainSpellSchools"],
         query: () => services.DomainSpellSchool.getAllItems()
      }),
      useGetDomainSpellSchoolByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainSpellSchoolById", id.toString()],
            query: () => services.DomainSpellSchool.getItemById(id)
         });
      },
      useSaveDomainSpellSchoolMutation: (obj: Parameters<typeof services.DomainSpellSchool.saveItem>[0]) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainSpellSchool.saveItem(obj),
            onSettled: async () => queryInvalidator(queryCache, ["getDomainSpellSchools", "getDomainSpellSchoolById"])
         });
      },
      
      //DomainStaticEffect
      useGetDomainStaticEffectsQuery: () => queryHandler({
         key: ["getDomainStaticEffects"],
         query: () => services.DomainStaticEffect.getAllItems()
      }),
      useGetDomainStaticEffectByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainStaticEffectById", id.toString()],
            query: () => services.DomainStaticEffect.getItemById(id)
         });
      },
      useSaveDomainStaticEffectMutation: (obj: Parameters<typeof services.DomainStaticEffect.saveItem>[0]) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainStaticEffect.saveItem(obj),
            onSettled: async () => queryInvalidator(queryCache, ["getDomainStaticEffects", "getDomainStaticEffectById"])
         });
      },
      
      //DomainSubClass
      useGetDomainSubClasssQuery: () => queryHandler({
         key: ["getDomainSubClasss"],
         query: () => services.DomainSubClass.getAllItems()
      }),
      useGetDomainSubClassByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainSubClassById", id.toString()],
            query: () => services.DomainSubClass.getItemById(id)
         });
      },
      useSaveDomainSubClassMutation: (obj: Parameters<typeof services.DomainSubClass.saveItem>[0]) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainSubClass.saveItem(obj),
            onSettled: async () => queryInvalidator(queryCache, ["getDomainSubClasss", "getDomainSubClassById"])
         });
      },
      
      //Quantifier
      useGetQuantifiersQuery: () => queryHandler({
         key: ["getQuantifiers"],
         query: () => services.Quantifier.getAllItems()
      }),
      useGetQuantifierByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getQuantifierById", id.toString()],
            query: () => services.Quantifier.getItemById(id)
         });
      },
      useSaveQuantifierMutation: (obj: Parameters<typeof services.Quantifier.saveItem>[0]) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.Quantifier.saveItem(obj),
            onSettled: async () => queryInvalidator(queryCache, ["getQuantifiers", "getQuantifierById"])
         });
      },
      
   }
}
