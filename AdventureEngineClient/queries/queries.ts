//*** CAUTION ***
//This is an autogenerated file produced by regenerateFrontendQueries.py.
//Edits made here will not persist after regeneration.

import { AppTypes } from "../types/appTypes/appTypes";
import type { SchemaObject } from "../types/SchemaObject";

export type ServiceInterface<T> = {
   getAllItems: () => Promise<Array<T>>
   getItemById: (id: number) => Promise<T>
   saveItem: <G extends T | T[]>(item: G) => Promise<G>
}

export type QueryServicesType = {[key in keyof typeof AppTypes]: ServiceInterface<typeof AppTypes[key]>}

export function composeQueryBuilderContext<
   T extends <G extends SchemaObject>(opts: {
      key: string[],
      query: (...args : any[]) => Promise<G | G[]>
   }) => ReturnType<T>,
   U extends <G extends SchemaObject>(opts: {
      mutation: (...args : any[]) => Promise<G>
      onSuccess: (data: G | G[], ...args: any[]) => any
   }) => ReturnType<U>,
   C extends () => ReturnType<C>,
   Q extends (cacheContext: ReturnType<C>, keys: string[]) => any,
>(
   queryHandler: T,
   mutationHandler: U,
   cacheHandler: C,queryInvalidator: Q,
   services: QueryServicesType
) {
   return {
      //Campaign
      useGetCampaignsQuery: () => queryHandler({
         key: ["getCampaigns"],
         query: () => services.Campaign.getAllItems()
      }),
      useGetCampaignByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getCampaignById", id.toString()],
            query: () => services.Campaign.getItemById(id)
         });
      },
      useSaveCampaignMutation: <H extends Parameters<typeof services.Campaign.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.Campaign.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getCampaigns",
                  "getCampaignById",
               ]);
            }
         });
      },
      
      //Character
      useGetCharactersQuery: () => queryHandler({
         key: ["getCharacters"],
         query: () => services.Character.getAllItems()
      }),
      useGetCharacterByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getCharacterById", id.toString()],
            query: () => services.Character.getItemById(id)
         });
      },
      useSaveCharacterMutation: <H extends Parameters<typeof services.Character.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.Character.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getCharacters",
                  "getCharacterById",
                  "getDomainSizes",
                  "getDomainSpeciess",
                  "getCampaigns",
                  "getDomainSizeById",
                  "getDomainSpeciesById",
                  "getCampaignById",
               ]);
            }
         });
      },
      
      //CharacterDomainCharacterStatInstance
      useGetCharacterDomainCharacterStatInstancesQuery: () => queryHandler({
         key: ["getCharacterDomainCharacterStatInstances"],
         query: () => services.CharacterDomainCharacterStatInstance.getAllItems()
      }),
      useGetCharacterDomainCharacterStatInstanceByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getCharacterDomainCharacterStatInstanceById", id.toString()],
            query: () => services.CharacterDomainCharacterStatInstance.getItemById(id)
         });
      },
      useSaveCharacterDomainCharacterStatInstanceMutation: <H extends Parameters<typeof services.CharacterDomainCharacterStatInstance.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.CharacterDomainCharacterStatInstance.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getCharacterDomainCharacterStatInstances",
                  "getCharacterDomainCharacterStatInstanceById",
                  "getCharacters",
                  "getDomainCharacterStats",
                  "getCharacterById",
                  "getDomainCharacterStatById",
               ]);
            }
         });
      },
      
      //CharacterDomainConditionInstance
      useGetCharacterDomainConditionInstancesQuery: () => queryHandler({
         key: ["getCharacterDomainConditionInstances"],
         query: () => services.CharacterDomainConditionInstance.getAllItems()
      }),
      useGetCharacterDomainConditionInstanceByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getCharacterDomainConditionInstanceById", id.toString()],
            query: () => services.CharacterDomainConditionInstance.getItemById(id)
         });
      },
      useSaveCharacterDomainConditionInstanceMutation: <H extends Parameters<typeof services.CharacterDomainConditionInstance.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.CharacterDomainConditionInstance.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getCharacterDomainConditionInstances",
                  "getCharacterDomainConditionInstanceById",
                  "getCharacters",
                  "getDomainConditions",
                  "getCharacterById",
                  "getDomainConditionById",
               ]);
            }
         });
      },
      
      //CharacterDomainSubClassInstance
      useGetCharacterDomainSubClassInstancesQuery: () => queryHandler({
         key: ["getCharacterDomainSubClassInstances"],
         query: () => services.CharacterDomainSubClassInstance.getAllItems()
      }),
      useGetCharacterDomainSubClassInstanceByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getCharacterDomainSubClassInstanceById", id.toString()],
            query: () => services.CharacterDomainSubClassInstance.getItemById(id)
         });
      },
      useSaveCharacterDomainSubClassInstanceMutation: <H extends Parameters<typeof services.CharacterDomainSubClassInstance.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.CharacterDomainSubClassInstance.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getCharacterDomainSubClassInstances",
                  "getCharacterDomainSubClassInstanceById",
                  "getCharacters",
                  "getDomainSubClasss",
                  "getCharacterById",
                  "getDomainSubClassById",
               ]);
            }
         });
      },
      
      //ClassPrimaryAbility
      useGetClassPrimaryAbilitysQuery: () => queryHandler({
         key: ["getClassPrimaryAbilitys"],
         query: () => services.ClassPrimaryAbility.getAllItems()
      }),
      useGetClassPrimaryAbilityByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getClassPrimaryAbilityById", id.toString()],
            query: () => services.ClassPrimaryAbility.getItemById(id)
         });
      },
      useSaveClassPrimaryAbilityMutation: <H extends Parameters<typeof services.ClassPrimaryAbility.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.ClassPrimaryAbility.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getClassPrimaryAbilitys",
                  "getClassPrimaryAbilityById",
                  "getDomainClasss",
                  "getDomainCharacterStats",
                  "getDomainClassById",
                  "getDomainCharacterStatById",
               ]);
            }
         });
      },
      
      //ClassSave
      useGetClassSavesQuery: () => queryHandler({
         key: ["getClassSaves"],
         query: () => services.ClassSave.getAllItems()
      }),
      useGetClassSaveByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getClassSaveById", id.toString()],
            query: () => services.ClassSave.getItemById(id)
         });
      },
      useSaveClassSaveMutation: <H extends Parameters<typeof services.ClassSave.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.ClassSave.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getClassSaves",
                  "getClassSaveById",
                  "getDomainClasss",
                  "getDomainCharacterStats",
                  "getDomainClassById",
                  "getDomainCharacterStatById",
               ]);
            }
         });
      },
      
      //ClassSpell
      useGetClassSpellsQuery: () => queryHandler({
         key: ["getClassSpells"],
         query: () => services.ClassSpell.getAllItems()
      }),
      useGetClassSpellByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getClassSpellById", id.toString()],
            query: () => services.ClassSpell.getItemById(id)
         });
      },
      useSaveClassSpellMutation: <H extends Parameters<typeof services.ClassSpell.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.ClassSpell.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getClassSpells",
                  "getClassSpellById",
                  "getDomainClasss",
                  "getDomainSpells",
                  "getDomainClassById",
                  "getDomainSpellById",
               ]);
            }
         });
      },
      
      //DomainAction
      useGetDomainActionsQuery: () => queryHandler({
         key: ["getDomainActions"],
         query: () => services.DomainAction.getAllItems()
      }),
      useGetDomainActionByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainActionById", id.toString()],
            query: () => services.DomainAction.getItemById(id)
         });
      },
      useSaveDomainActionMutation: <H extends Parameters<typeof services.DomainAction.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainAction.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getDomainActions",
                  "getDomainActionById",
               ]);
            }
         });
      },
      
      //DomainCharacterStat
      useGetDomainCharacterStatsQuery: () => queryHandler({
         key: ["getDomainCharacterStats"],
         query: () => services.DomainCharacterStat.getAllItems()
      }),
      useGetDomainCharacterStatByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainCharacterStatById", id.toString()],
            query: () => services.DomainCharacterStat.getItemById(id)
         });
      },
      useSaveDomainCharacterStatMutation: <H extends Parameters<typeof services.DomainCharacterStat.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainCharacterStat.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getDomainCharacterStats",
                  "getDomainCharacterStatById",
               ]);
            }
         });
      },
      
      //DomainClass
      useGetDomainClasssQuery: () => queryHandler({
         key: ["getDomainClasss"],
         query: () => services.DomainClass.getAllItems()
      }),
      useGetDomainClassByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainClassById", id.toString()],
            query: () => services.DomainClass.getItemById(id)
         });
      },
      useSaveDomainClassMutation: <H extends Parameters<typeof services.DomainClass.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainClass.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getDomainClasss",
                  "getDomainClassById",
                  "getDomainDices",
                  "getDomainCharacterStats",
                  "getDomainDiceById",
                  "getDomainCharacterStatById",
               ]);
            }
         });
      },
      
      //DomainClassResource
      useGetDomainClassResourcesQuery: () => queryHandler({
         key: ["getDomainClassResources"],
         query: () => services.DomainClassResource.getAllItems()
      }),
      useGetDomainClassResourceByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainClassResourceById", id.toString()],
            query: () => services.DomainClassResource.getItemById(id)
         });
      },
      useSaveDomainClassResourceMutation: <H extends Parameters<typeof services.DomainClassResource.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainClassResource.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getDomainClassResources",
                  "getDomainClassResourceById",
                  "getDomainClasss",
                  "getDomainSubClasss",
                  "getDomainClassById",
                  "getDomainSubClassById",
               ]);
            }
         });
      },
      
      //DomainClassTrait
      useGetDomainClassTraitsQuery: () => queryHandler({
         key: ["getDomainClassTraits"],
         query: () => services.DomainClassTrait.getAllItems()
      }),
      useGetDomainClassTraitByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainClassTraitById", id.toString()],
            query: () => services.DomainClassTrait.getItemById(id)
         });
      },
      useSaveDomainClassTraitMutation: <H extends Parameters<typeof services.DomainClassTrait.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainClassTrait.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getDomainClassTraits",
                  "getDomainClassTraitById",
                  "getDomainSubClasss",
                  "getDomainClasss",
                  "getDomainSubClassById",
                  "getDomainClassById",
               ]);
            }
         });
      },
      
      //DomainCondition
      useGetDomainConditionsQuery: () => queryHandler({
         key: ["getDomainConditions"],
         query: () => services.DomainCondition.getAllItems()
      }),
      useGetDomainConditionByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainConditionById", id.toString()],
            query: () => services.DomainCondition.getItemById(id)
         });
      },
      useSaveDomainConditionMutation: <H extends Parameters<typeof services.DomainCondition.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainCondition.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getDomainConditions",
                  "getDomainConditionById",
               ]);
            }
         });
      },
      
      //DomainCreatureType
      useGetDomainCreatureTypesQuery: () => queryHandler({
         key: ["getDomainCreatureTypes"],
         query: () => services.DomainCreatureType.getAllItems()
      }),
      useGetDomainCreatureTypeByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainCreatureTypeById", id.toString()],
            query: () => services.DomainCreatureType.getItemById(id)
         });
      },
      useSaveDomainCreatureTypeMutation: <H extends Parameters<typeof services.DomainCreatureType.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainCreatureType.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getDomainCreatureTypes",
                  "getDomainCreatureTypeById",
               ]);
            }
         });
      },
      
      //DomainDamageType
      useGetDomainDamageTypesQuery: () => queryHandler({
         key: ["getDomainDamageTypes"],
         query: () => services.DomainDamageType.getAllItems()
      }),
      useGetDomainDamageTypeByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainDamageTypeById", id.toString()],
            query: () => services.DomainDamageType.getItemById(id)
         });
      },
      useSaveDomainDamageTypeMutation: <H extends Parameters<typeof services.DomainDamageType.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainDamageType.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getDomainDamageTypes",
                  "getDomainDamageTypeById",
               ]);
            }
         });
      },
      
      //DomainDice
      useGetDomainDicesQuery: () => queryHandler({
         key: ["getDomainDices"],
         query: () => services.DomainDice.getAllItems()
      }),
      useGetDomainDiceByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainDiceById", id.toString()],
            query: () => services.DomainDice.getItemById(id)
         });
      },
      useSaveDomainDiceMutation: <H extends Parameters<typeof services.DomainDice.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainDice.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getDomainDices",
                  "getDomainDiceById",
               ]);
            }
         });
      },
      
      //DomainDiceRollSubType
      useGetDomainDiceRollSubTypesQuery: () => queryHandler({
         key: ["getDomainDiceRollSubTypes"],
         query: () => services.DomainDiceRollSubType.getAllItems()
      }),
      useGetDomainDiceRollSubTypeByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainDiceRollSubTypeById", id.toString()],
            query: () => services.DomainDiceRollSubType.getItemById(id)
         });
      },
      useSaveDomainDiceRollSubTypeMutation: <H extends Parameters<typeof services.DomainDiceRollSubType.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainDiceRollSubType.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getDomainDiceRollSubTypes",
                  "getDomainDiceRollSubTypeById",
                  "getDomainDiceRollTypes",
                  "getDomainDiceRollTypeById",
               ]);
            }
         });
      },
      
      //DomainDiceRollType
      useGetDomainDiceRollTypesQuery: () => queryHandler({
         key: ["getDomainDiceRollTypes"],
         query: () => services.DomainDiceRollType.getAllItems()
      }),
      useGetDomainDiceRollTypeByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainDiceRollTypeById", id.toString()],
            query: () => services.DomainDiceRollType.getItemById(id)
         });
      },
      useSaveDomainDiceRollTypeMutation: <H extends Parameters<typeof services.DomainDiceRollType.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainDiceRollType.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getDomainDiceRollTypes",
                  "getDomainDiceRollTypeById",
               ]);
            }
         });
      },
      
      //DomainItem
      useGetDomainItemsQuery: () => queryHandler({
         key: ["getDomainItems"],
         query: () => services.DomainItem.getAllItems()
      }),
      useGetDomainItemByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainItemById", id.toString()],
            query: () => services.DomainItem.getItemById(id)
         });
      },
      useSaveDomainItemMutation: <H extends Parameters<typeof services.DomainItem.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainItem.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getDomainItems",
                  "getDomainItemById",
                  "getQuantifiers",
                  "getQuantifiers",
                  "getQuantifierById",
                  "getQuantifierById",
               ]);
            }
         });
      },
      
      //DomainSize
      useGetDomainSizesQuery: () => queryHandler({
         key: ["getDomainSizes"],
         query: () => services.DomainSize.getAllItems()
      }),
      useGetDomainSizeByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainSizeById", id.toString()],
            query: () => services.DomainSize.getItemById(id)
         });
      },
      useSaveDomainSizeMutation: <H extends Parameters<typeof services.DomainSize.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainSize.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getDomainSizes",
                  "getDomainSizeById",
               ]);
            }
         });
      },
      
      //DomainSpecies
      useGetDomainSpeciessQuery: () => queryHandler({
         key: ["getDomainSpeciess"],
         query: () => services.DomainSpecies.getAllItems()
      }),
      useGetDomainSpeciesByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainSpeciesById", id.toString()],
            query: () => services.DomainSpecies.getItemById(id)
         });
      },
      useSaveDomainSpeciesMutation: <H extends Parameters<typeof services.DomainSpecies.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainSpecies.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getDomainSpeciess",
                  "getDomainSpeciesById",
                  "getDomainCreatureTypes",
                  "getDomainCreatureTypeById",
               ]);
            }
         });
      },
      
      //DomainSpell
      useGetDomainSpellsQuery: () => queryHandler({
         key: ["getDomainSpells"],
         query: () => services.DomainSpell.getAllItems()
      }),
      useGetDomainSpellByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainSpellById", id.toString()],
            query: () => services.DomainSpell.getItemById(id)
         });
      },
      useSaveDomainSpellMutation: <H extends Parameters<typeof services.DomainSpell.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainSpell.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getDomainSpells",
                  "getDomainSpellById",
                  "getDomainSpellSchools",
                  "getDomainDices",
                  "getDomainSpellSchoolById",
                  "getDomainDiceById",
               ]);
            }
         });
      },
      
      //DomainSpellSchool
      useGetDomainSpellSchoolsQuery: () => queryHandler({
         key: ["getDomainSpellSchools"],
         query: () => services.DomainSpellSchool.getAllItems()
      }),
      useGetDomainSpellSchoolByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainSpellSchoolById", id.toString()],
            query: () => services.DomainSpellSchool.getItemById(id)
         });
      },
      useSaveDomainSpellSchoolMutation: <H extends Parameters<typeof services.DomainSpellSchool.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainSpellSchool.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getDomainSpellSchools",
                  "getDomainSpellSchoolById",
               ]);
            }
         });
      },
      
      //DomainStaticEffect
      useGetDomainStaticEffectsQuery: () => queryHandler({
         key: ["getDomainStaticEffects"],
         query: () => services.DomainStaticEffect.getAllItems()
      }),
      useGetDomainStaticEffectByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainStaticEffectById", id.toString()],
            query: () => services.DomainStaticEffect.getItemById(id)
         });
      },
      useSaveDomainStaticEffectMutation: <H extends Parameters<typeof services.DomainStaticEffect.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainStaticEffect.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getDomainStaticEffects",
                  "getDomainStaticEffectById",
               ]);
            }
         });
      },
      
      //DomainSubClass
      useGetDomainSubClasssQuery: () => queryHandler({
         key: ["getDomainSubClasss"],
         query: () => services.DomainSubClass.getAllItems()
      }),
      useGetDomainSubClassByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getDomainSubClassById", id.toString()],
            query: () => services.DomainSubClass.getItemById(id)
         });
      },
      useSaveDomainSubClassMutation: <H extends Parameters<typeof services.DomainSubClass.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.DomainSubClass.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getDomainSubClasss",
                  "getDomainSubClassById",
                  "getDomainClasss",
                  "getDomainClassById",
               ]);
            }
         });
      },
      
      //EvaluatedConditional
      useGetEvaluatedConditionalsQuery: () => queryHandler({
         key: ["getEvaluatedConditionals"],
         query: () => services.EvaluatedConditional.getAllItems()
      }),
      useGetEvaluatedConditionalByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getEvaluatedConditionalById", id.toString()],
            query: () => services.EvaluatedConditional.getItemById(id)
         });
      },
      useSaveEvaluatedConditionalMutation: <H extends Parameters<typeof services.EvaluatedConditional.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.EvaluatedConditional.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getEvaluatedConditionals",
                  "getEvaluatedConditionalById",
                  "getDomainConditions",
                  "getQuantifiers",
                  "getQuantifiers",
                  "getDomainConditionById",
                  "getQuantifierById",
                  "getQuantifierById",
               ]);
            }
         });
      },
      
      //Quantifier
      useGetQuantifiersQuery: () => queryHandler({
         key: ["getQuantifiers"],
         query: () => services.Quantifier.getAllItems()
      }),
      useGetQuantifierByIdQuery: (id: number) => {
         //For some reason queries with args does not work without the extra function body/return.
         //Not a huge deal, but apparently a Colada quirk for dynamic-ish queries
         return queryHandler({
            key: ["getQuantifierById", id.toString()],
            query: () => services.Quantifier.getItemById(id)
         });
      },
      useSaveQuantifierMutation: <H extends Parameters<typeof services.Quantifier.saveItem>[0]>(obj: H, onSuccess: (data: H) => any) => {
         const queryCache = cacheHandler();
         return mutationHandler({
            mutation: () => services.Quantifier.saveItem(obj),
            onSuccess: async (data: H, ...args) => {
               //This is a standin for ".then(value => ...)" since for SOME reason mutations don't allow you to get the value back directly
               onSuccess(data);
               queryInvalidator(queryCache, [
                  "getQuantifiers",
                  "getQuantifierById",
                  "getDomainActions",
                  "getDomainStaticEffects",
                  "getDomainConditions",
                  "getDomainClassTraits",
                  "getDomainSubClasss",
                  "getDomainClasss",
                  "getDomainStaticEffects",
                  "getDomainCharacterStats",
                  "getDomainDiceRollTypes",
                  "getDomainDiceRollSubTypes",
                  "getDomainActions",
                  "getDomainSpells",
                  "getDomainConditions",
                  "getDomainDamageTypes",
                  "getDomainActionById",
                  "getDomainStaticEffectById",
                  "getDomainConditionById",
                  "getDomainClassTraitById",
                  "getDomainSubClassById",
                  "getDomainClassById",
                  "getDomainStaticEffectById",
                  "getDomainCharacterStatById",
                  "getDomainDiceRollTypeById",
                  "getDomainDiceRollSubTypeById",
                  "getDomainActionById",
                  "getDomainSpellById",
                  "getDomainConditionById",
                  "getDomainDamageTypeById",
               ]);
            }
         });
      },
      
   }
}
